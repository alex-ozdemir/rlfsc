(declare bool type)
(declare tt bool)
(declare ff bool)

(declare var type)

(declare lit type)
(declare pos (! x var lit))
(declare neg (! x var lit))

; Flip the polarity of the literal
(program lit_flip ((l lit)) lit
         (match l
                ((pos v) (neg v))
                ((neg v) (pos v))))

(declare clause type)
(declare cln clause)
(declare clc (! x lit (! c clause clause)))

; A list of clauses, CNF if interpretted as a formula,
; but also sometimes just a list
(declare cnf type)
(declare cnfn cnf)
(declare cnfc (! h clause (! t cnf cnf)))

; constructs for general clauses for R, Q, satlem

(declare concat_cl (! c1 clause (! c2 clause clause)))
(declare clr (! l lit (! c clause clause)))

; code to check resolutions

(program clause_append ((c1 clause) (c2 clause)) clause
  (match c1 (cln c2) ((clc l c1') (clc l (clause_append c1' c2)))))

; we use marks as follows:
; -- mark 1 to record if we are supposed to remove a positive occurrence of the variable.
; -- mark 2 to record if we are supposed to remove a negative occurrence of the variable.
; -- mark 3 if we did indeed remove the variable positively
; -- mark 4 if we did indeed remove the variable negatively
(program simplify_clause ((c clause)) clause
  (match c
    (cln cln)
    ((clc l c1)
      (match l
        ; Set mark 1 on v if it is not set, to indicate we should remove it.
        ; After processing the rest of the clause, set mark 3 if we were already
        ; supposed to remove v (so if mark 1 was set when we began).  Clear mark3
        ; if we were not supposed to be removing v when we began this call.
        ((pos v)
          (let m (ifmarked v tt (do (markvar v) ff))
          (let c' (simplify_clause c1)
            (match m
              (tt (do (ifmarked3 v v (markvar3 v)) c'))
              (ff (do (ifmarked3 v (markvar3 v) v) (markvar v) (clc l c')))))))
        ; the same as the code for tt, but using different marks.
        ((neg v)
          (let m (ifmarked2 v tt (do (markvar2 v) ff))
          (let c' (simplify_clause c1)
            (match m
              (tt (do (ifmarked4 v v (markvar4 v)) c'))
              (ff (do (ifmarked4 v (markvar4 v) v) (markvar2 v) (clc l c')))))))))
    ((concat_cl c1 c2) (clause_append (simplify_clause c1) (simplify_clause c2)))
    ((clr l c1)
      (match l
        ; set mark 1 to indicate we should remove v, and fail if
        ; mark 3 is not set after processing the rest of the clause
        ; (we will set mark 3 if we remove a positive occurrence of v).
        ((pos v)
            (let m (ifmarked v tt (do (markvar v) ff))
            (let m3 (ifmarked3 v (do (markvar3 v) tt) ff)
            (let c' (simplify_clause c1)
              (ifmarked3 v (do (match m3 (tt v) (ff (markvar3 v)))
                                (match m (tt v) (ff (markvar v))) c')
                          (fail clause))))))
        ; same as the tt case, but with different marks.
        ((neg v)
            (let m2 (ifmarked2 v tt (do (markvar2 v) ff))
            (let m4 (ifmarked4 v (do (markvar4 v) tt) ff)
            (let c' (simplify_clause c1)
              (ifmarked4 v (do (match m4 (tt v) (ff (markvar4 v)))
                                (match m2 (tt v) (ff (markvar2 v))) c')
                          (fail clause))))))
   ))))


; resolution proofs

(declare holds (! c clause type))

(declare R (! c1 clause (! c2 clause
           (! u1 (holds c1)
           (! u2 (holds c2)
           (! n var
            (holds (concat_cl (clr (pos n) c1)
                     (clr (neg n) c2)))))))))

(declare Q (! c1 clause (! c2 clause
           (! u1 (holds c1)
           (! u2 (holds c2)
           (! n var
            (holds (concat_cl (clr (neg n) c1)
                     (clr (pos n) c2)))))))))

(declare satlem_simplify
                (! c1 clause
                (! c2 clause
                (! c3 clause
                (! u1 (holds c1)
                (! r (^ (simplify_clause c1) c2)
                (! u2 (! x (holds c2) (holds c3))
                   (holds c3))))))))

(declare satlem
  (! c clause
  (! c2 clause
  (! u (holds c)
  (! u2 (! v (holds c) (holds c2))
    (holds c2))))))


; Returns a copy of `c` with any duplicate literals removed.
; Never fails.
; Uses marks 3 & 4. Expects them to be clear before hand, and leaves them clear
; afterwards.
(program clause_dedup ((c clause)) clause
         (match c
                (cln cln)
                ((clc l rest)
                 (match l
                        ((pos v) (ifmarked3
                                   v
                                   (clause_dedup rest)
                                   (do (markvar3 v)
                                     (let result (clc (pos v) (clause_dedup rest))
                                       (do (markvar3 v) result)))))
                        ((neg v) (ifmarked4
                                   v
                                   (clause_dedup rest)
                                   (do (markvar4 v)
                                     (let result (clc (neg v) (clause_dedup rest))
                                       (do (markvar4 v) result)))))))))

(declare cnf_holds (! c cnf type))
(declare cnfn_proof (cnf_holds cnfn))
(declare cnfc_proof
         (! c clause
         (! deduped_c clause
            (! rest cnf
               (! proof_c (holds c)
                  (! proof_rest (cnf_holds rest)
                     (! sc (^ (clause_dedup c) deduped_c)
                        (cnf_holds (cnfc c rest)))))))))

; A little example to demonstrate simplify_clause.
; It can handle nested clr's of both polarities,
; and correctly cleans up marks when it leaves a
; clr or clc scope.  Uncomment and run with
; --show-runs to see it in action.
;
; (check
;   (% v1 var
;   (% u1 (holds (concat_cl (clr (neg v1) (clr (pos v1) (clc (pos v1) (clr (pos v1) (clc (pos v1) (clc (neg v1) cln))))))
;                    (clc (pos v1) (clc (pos v1) cln))))
;    (satlem _ _ _ u1 (\ x x))))))


;(check
;   (% v1 var
;   (% u1 (holds (clr (neg v1) (concat_cl (clc (neg v1) cln)
;                                      (clr (neg v1) (clc (neg v1) cln)))))
;    (satlem _ _ _ u1 (\ x x))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; SMT syntax and semantics (not theory-specific)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; depends on sat.plf

(declare formula type)
(declare th_holds (! f formula type))

; standard logic definitions
(declare true formula)
(declare false formula)

(define formula_op1
	(! f formula
	formula))

(define formula_op2
	(! f1 formula
	(! f2 formula
	   formula)))

(define formula_op3
	(! f1 formula
	(! f2 formula
	(! f3 formula
	   formula))))

(declare not formula_op1)
(declare and formula_op2)
(declare or formula_op2)
(declare impl formula_op2)
(declare iff formula_op2)
(declare xor formula_op2)
(declare ifte formula_op3)

; terms
(declare sort type)
(declare term (! t sort type))	; declared terms in formula

; standard definitions for =, ite, let and flet
(declare = (! s sort
           (! x (term s)
           (! y (term s)
             formula))))
(declare ite (! s sort
             (! f formula
             (! t1 (term s)
             (! t2 (term s)
               (term s))))))
; TODO(aozdemir) allow this.
;(declare let (! s sort
;             (! t (term s)
;             (! f (! v (term s) formula)
;               formula))))
(declare flet (! f1 formula
              (! f2 (! v formula formula)
                formula)))

; We view applications of predicates as terms of sort "Bool".
; Such terms can be injected as atomic formulas using "p_app".
(declare Bool sort)				; the special sort for predicates
(declare p_app (! x (term Bool) formula))	; propositional application of term

; boolean terms
(declare t_true (term Bool))
(declare t_false (term Bool))
(declare t_t_neq_f
 (th_holds (not (= Bool t_true t_false))))
(declare pred_eq_t
 (! x (term Bool)
 (! u (th_holds (p_app x))
   (th_holds (= Bool x t_true)))))

(declare pred_eq_f
 (! x (term Bool)
 (! u (th_holds (not (p_app x)))
   (th_holds (= Bool x t_false)))))

(declare f_to_b
  (! f formula
    (term Bool)))

(declare true_preds_equal
  (! x1 (term Bool)
  (! x2 (term Bool)
  (! u1 (th_holds (p_app x1))
  (! u2 (th_holds (p_app x2))
    (th_holds (= Bool x1 x2)))))))

(declare false_preds_equal
  (! x1 (term Bool)
  (! x2 (term Bool)
  (! u1 (th_holds (not (p_app x1)))
  (! u2 (th_holds (not (p_app x2)))
    (th_holds (= Bool x1 x2)))))))

(declare pred_refl_pos
  (! x1 (term Bool)
  (! u1 (th_holds (p_app x1))
    (th_holds (= Bool x1 x1)))))

(declare pred_refl_neg
  (! x1 (term Bool)
  (! u1 (th_holds (not (p_app x1)))
    (th_holds (= Bool x1 x1)))))

(declare pred_not_iff_f
  (! x (term Bool)
  (! u (th_holds (not (iff false (p_app x))))
    (th_holds (= Bool t_true x)))))

(declare pred_not_iff_f_2
  (! x (term Bool)
  (! u (th_holds (not (iff (p_app x) false)))
    (th_holds (= Bool x t_true)))))

(declare pred_not_iff_t
  (! x (term Bool)
  (! u (th_holds (not (iff true (p_app x))))
    (th_holds (= Bool t_false x)))))

(declare pred_not_iff_t_2
  (! x (term Bool)
  (! u (th_holds (not (iff (p_app x) true)))
    (th_holds (= Bool x t_false)))))

(declare pred_iff_f
  (! x (term Bool)
  (! u (th_holds (iff false (p_app x)))
    (th_holds (= Bool t_false x)))))

(declare pred_iff_f_2
  (! x (term Bool)
  (! u (th_holds (iff (p_app x) false))
    (th_holds (= Bool x t_false)))))

(declare pred_iff_t
  (! x (term Bool)
  (! u (th_holds (iff true (p_app x)))
    (th_holds (= Bool t_true x)))))

(declare pred_iff_t_2
  (! x (term Bool)
  (! u (th_holds (iff (p_app x) true))
    (th_holds (= Bool x t_true)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CNF Clausification
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; binding between an LF var and an (atomic) formula

(declare atom (! v var (! p formula type)))

; binding between two LF vars
(declare bvatom (! sat_v var (! bv_v var type)))

(declare decl_atom
  (! f formula
  (! u (! v var
       (! a (atom v f)
         (holds cln)))
    (holds cln))))

;; declare atom enhanced with mapping
;; between SAT prop variable and BVSAT prop variable
(declare decl_bvatom
  (! f formula
  (! u (! v var
       (! bv_v var
       (! a (atom v f)
       (! bva (atom bv_v f)
       (! vbv (bvatom v bv_v)
         (holds cln))))))
    (holds cln))))


; clausify a formula directly
(declare clausify_form
  (! f formula
  (! v var
  (! a (atom v f)
  (! u (th_holds f)
    (holds (clc (pos v) cln)))))))

(declare clausify_form_not
  (! f formula
  (! v var
  (! a (atom v f)
  (! u (th_holds (not f))
    (holds (clc (neg v) cln)))))))

(declare clausify_false
  (! u (th_holds false)
    (holds cln)))

(declare th_let_pf
  (! f formula
  (! u (th_holds f)
  (! u2 (! v (th_holds f) (holds cln))
    (holds cln)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Natural deduction rules : used for CNF
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; for eager bit-blasting
(declare iff_symm
	(! f formula
	   (th_holds (iff f f))))


;; contradiction

(declare contra
  (! f formula
  (! r1 (th_holds f)
  (! r2 (th_holds (not f))
    (th_holds false)))))

; truth
(declare truth (th_holds true))

;; not not

(declare not_not_intro
  (! f formula
  (! u (th_holds f)
    (th_holds (not (not f))))))

(declare not_not_elim
  (! f formula
  (! u (th_holds (not (not f)))
    (th_holds f))))

;; or elimination

(declare or_elim_1
  (! f1 formula
  (! f2 formula
  (! u1 (th_holds (not f1))
  (! u2 (th_holds (or f1 f2))
    (th_holds f2))))))

(declare or_elim_2
  (! f1 formula
  (! f2 formula
  (! u1 (th_holds (not f2))
  (! u2 (th_holds (or f1 f2))
    (th_holds f1))))))

(declare not_or_elim
  (! f1 formula
  (! f2 formula
  (! u2 (th_holds (not (or f1 f2)))
    (th_holds (and (not f1) (not f2)))))))

;; and elimination

(declare and_elim_1
  (! f1 formula
  (! f2 formula
  (! u (th_holds (and f1 f2))
    (th_holds f1)))))

(declare and_elim_2
  (! f1 formula
  (! f2 formula
  (! u (th_holds (and f1 f2))
    (th_holds f2)))))

(declare not_and_elim
  (! f1 formula
  (! f2 formula
  (! u2 (th_holds (not (and f1 f2)))
    (th_holds (or (not f1) (not f2)))))))

;; impl elimination

(declare impl_intro (! f1 formula
                    (! f2 formula
                    (! i1 (! u (th_holds f1)
                              (th_holds f2))
                      (th_holds (impl f1 f2))))))

(declare impl_elim
  (! f1 formula
  (! f2 formula
  (! u2 (th_holds (impl f1 f2))
    (th_holds (or (not f1) f2))))))

(declare not_impl_elim
  (! f1 formula
  (! f2 formula
  (! u (th_holds (not (impl f1 f2)))
    (th_holds (and f1 (not f2)))))))

;; iff elimination

(declare iff_elim_1
  (! f1 formula
  (! f2 formula
  (! u1 (th_holds (iff f1 f2))
    (th_holds (or (not f1) f2))))))

(declare iff_elim_2
  (! f1 formula
  (! f2 formula
  (! u1 (th_holds (iff f1 f2))
    (th_holds (or f1 (not f2)))))))

(declare not_iff_elim
  (! f1 formula
  (! f2 formula
  (! u2 (th_holds (not (iff f1 f2)))
    (th_holds (iff f1 (not f2)))))))

; xor elimination

(declare xor_elim_1
  (! f1 formula
  (! f2 formula
  (! u1 (th_holds (xor f1 f2))
    (th_holds (or (not f1) (not f2)))))))

(declare xor_elim_2
  (! f1 formula
  (! f2 formula
  (! u1 (th_holds (xor f1 f2))
    (th_holds (or f1 f2))))))

(declare not_xor_elim
  (! f1 formula
  (! f2 formula
  (! u2 (th_holds (not (xor f1 f2)))
    (th_holds (iff f1 f2))))))

;; ite elimination

(declare ite_elim_1
  (! a formula
  (! b formula
  (! c formula
  (! u2 (th_holds (ifte a b c))
    (th_holds (or (not a) b)))))))

(declare ite_elim_2
  (! a formula
  (! b formula
  (! c formula
  (! u2 (th_holds (ifte a b c))
    (th_holds (or a c)))))))

(declare ite_elim_3
  (! a formula
  (! b formula
  (! c formula
  (! u2 (th_holds (ifte a b c))
    (th_holds (or b c)))))))

(declare not_ite_elim_1
  (! a formula
  (! b formula
  (! c formula
  (! u2 (th_holds (not (ifte a b c)))
    (th_holds (or (not a) (not b))))))))

(declare not_ite_elim_2
  (! a formula
  (! b formula
  (! c formula
  (! u2 (th_holds (not (ifte a b c)))
    (th_holds (or a (not c))))))))

(declare not_ite_elim_3
  (! a formula
  (! b formula
  (! c formula
  (! u2 (th_holds (not (ifte a b c)))
    (th_holds (or (not b) (not c))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; For theory lemmas
; - make a series of assumptions and then derive a contradiction (or false)
; - then the assumptions yield a formula like "v1 -> v2 -> ... -> vn -> false"
; - In CNF, it becomes a clause: "~v1, ~v2, ..., ~vn"
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(declare ast
  (! v var
  (! f formula
  (! C clause
  (! r (atom v f)       ;this is specified
  (! u (! o (th_holds f)
         (holds C))
    (holds (clc (neg v) C))))))))

(declare asf
  (! v var
  (! f formula
  (! C clause
  (! r (atom v f)
  (! u (! o (th_holds (not f))
         (holds C))
    (holds (clc (pos v) C))))))))

;; Bitvector lemma constructors to assume
;; the unit clause containing the assumptions
;; it also requires the mapping between bv_v and v
;; The resolution proof proving false will use bv_v as the definition clauses use bv_v
;; but the Problem clauses in the main SAT solver will use v so the learned clause is in terms of v
(declare bv_asf
  (! v var
  (! bv_v var
  (! f formula
  (! C clause
  (! r (atom v f) ;; passed in
  (! x (bvatom v bv_v) ; establishes the equivalence of v to bv_
  (! u (! o (holds (clc (neg bv_v) cln)) ;; l binding to be used in proof
         (holds C))
    (holds (clc (pos v) C))))))))))

(declare bv_ast
  (! v var
  (! bv_v var
  (! f formula
  (! C clause
  (! r (atom v f)       ; this is specified
  (! x (bvatom v bv_v) ; establishes the equivalence of v to bv_v
  (! u (! o (holds (clc (pos bv_v) cln))
         (holds C))
    (holds (clc (neg v) C))))))))))

;; Numeric primitives

(program mpz_sub ((x mpz) (y mpz)) mpz
	 (mp_add x (mp_mul (~1) y)))

(program mp_ispos ((x mpz)) formula
	 (mp_ifneg x false true))

(program mpz_eq ((x mpz) (y mpz)) formula
    (mp_ifzero (mpz_sub x y) true false))

(program mpz_lt ((x mpz) (y mpz)) formula
    (mp_ifneg (mpz_sub x y) true false))

(program mpz_lte ((x mpz) (y mpz)) formula
    (mp_ifneg (mpz_sub x y) true (mpz_eq x y)))

;; Example:
;;
;; Given theory literals (F1....Fn), and an input formula A of the form (th_holds (or F1 (or F2 .... (or F{n-1} Fn))))).
;;
;; We introduce atoms (a1,...,an) to map boolean literals (v1,...,vn) top literals (F1,...,Fn).
;; Do this at the beginning of the proof:
;;
;; (decl_atom F1 (\ v1 (\ a1
;; (decl_atom F2 (\ v2 (\ a2
;; ....
;; (decl_atom Fn (\ vn (\ an
;;
;;  A is then clausified by the following proof:
;;
;;(satlem _ _
;;(asf _ _ _ a1 (\ l1
;;(asf _ _ _ a2 (\ l2
;;...
;;(asf _ _ _ an (\ ln
;;(clausify_false
;;
;;   (contra _
;;      (or_elim_1 _ _ l{n-1}
;;	...
;;      (or_elim_1 _ _ l2
;; 	(or_elim_1 _ _ l1 A))))) ln)
;;
;;))))))) (\ C
;;
;; We now have the free variable C, which should be the clause (v1 V ... V vn).
;;
;; Polarity of literals should be considered, say we have A of the form (th_holds (or (not F1) (or F2 (not F3)))).
;; Where necessary, we use "ast" instead of "asf", introduce negations by "not_not_intro" for pattern matching, and flip
;; the arguments of contra:
;;
;;(satlem _ _
;;(ast _ _ _ a1 (\ l1
;;(asf _ _ _ a2 (\ l2
;;(ast _ _ _ a3 (\ l3
;;(clausify_false
;;
;;   (contra _ l3
;;      (or_elim_1 _ _ l2
;; 	(or_elim_1 _ _ (not_not_intro l1) A))))
;;
;;))))))) (\ C
;;
;; C should be the clause (~v1 V v2 V ~v3 )
; LRAT Proof signature
; LRAT format detailed in "Efficient Certified RAT Verification"
; Link: https://www.cs.utexas.edu/~marijn/publications/lrat.pdf
; Author: aozdemir
; Depends On: sat.plf, smt.plf


; A general note about the design of the side conditions:
;  Some side-conditions make use of a _global assignment_ encoded in
;  0 (true) / 1 (false) marks on variables.

; Unit (https://en.wikipedia.org/wiki/Unit_type)
; For functions that don't return anything
(declare Unit type) ; The type with only one value (like `void` in C)
(declare unit Unit) ; That value

; Boolean operator (not short-circuiting)
(program bool_or ((l bool) (r bool)) bool (match l (ff r) (tt tt)))
(program bool_and ((l bool) (r bool)) bool (match l (tt r) (ff ff)))
(program bool_not ((b bool)) bool (match b (tt ff) (ff tt)))
(program bool_eq ((l bool) (r bool)) bool
         (match l
                (tt (match r
                           (tt tt)
                           (ff ff)))
                (ff (match r
                           (tt ff)
                           (ff tt)))))

; =================== ;
; Working CNF formula ;
; =================== ;

; Represents a CNF formula as a map from clause indices to clauses
; Should be sorted ascending, always!
; Here, and for all collections, the suffix "n" denotes the empty collection and
; the suffix "c" denotes the constructor for the collection in the style of lisp's
; "cons cells"
(declare CMap type)
(declare CMapn CMap)
(declare CMapc (! i mpz (! c clause (! r CMap CMap))))

; ================= ;
; LRAT Proof Format ;
; ================= ;

; CI lists are lists of clause indices.
; They represent clauses to delete.
; They must be sorted.
(declare CIList type)
(declare CIListn CIList)
(declare CIListc (! z mpz (! zs CIList CIList)))

; Traces are a list of clause indices into the working CNF formula
; They represent the clauses that will be unit in a unit propegation to bottom
; Thus their elements are *not* in value order.
(declare Trace type)
(declare Tracen Trace)
(declare Tracec (! z mpz (! zs Trace Trace)))

; RAT Hint list
; Each hint is
;   * An index indicating a clause in the working CNF formula to resolve with
;   * A trace indicating how UP should be done after that resolution
(declare RATHints type)
(declare RATHintsn RATHints)
(declare RATHintsc
         (! target mpz
            (! trace Trace
               (! rest RATHints
                  RATHints))))

; LRAT proof
(declare LRATProof type)
(declare LRATProofn LRATProof)
; Deletion (includes a list of clause indices to delete)
(declare LRATProofd (! cis CIList (! rest LRATProof LRATProof)))
; Addition: a clause index, a clause, RUP trace for that clause, and hints for
; what resolutions should happen then, and how those resolutions imply bottom
; via UP.
; If the list of hints is empty, then bottom is already implied.
(declare LRATProofa
         (! ci mpz
            (! c clause
               (! t Trace
                  (! h RATHints
                     (! rest LRATProof
                        LRATProof))))))

; ========================================== ;
; Functional programs for manipulating types ;
; ========================================== ;

; Are two literal equal?
(program lit_eq ((l1 lit) (l2 lit)) bool
         (match l1
                ((pos v1) (match l2
                                 ((pos v2) (ifequal v1 v2 tt ff))
                                 ((neg v2) ff)))
                ((neg v1) (match l2
                                 ((pos v2) ff)
                                 ((neg v2) (ifequal v1 v2 tt ff))))))

; Remove **all** occurences of a literal from clause
(program clause_remove_all ((l lit) (c clause)) clause
         (match c
                (cln cln)
                ((clc l' c')
                 (let rest_res (clause_remove_all l c')
                   (match (lit_eq l l')
                          (tt rest_res)
                          (ff (clc l' rest_res)))))))

; Return the clause's first  literal
; fails on an empty clause
(program clause_head ((c clause)) lit
         (match c
                (cln (fail lit))
                ((clc l c') l)))

; Does a clause contain some literal?
(program clause_contains_lit ((c clause) (l lit)) bool
         (match c
                ((clc l' c') (match (lit_eq l l')
                                    (tt tt)
                                    (ff (clause_contains_lit c' l))))
                (cln ff)))

; Append two traces
(program Trace_concat ((t1 Trace) (t2 Trace)) Trace
         (match t1
                (Tracen t2)
                ((Tracec h1 r1) (Tracec h1 (Trace_concat r1 t2)))))

; Return whether a list of RAT hits is empty
(program RATHints_is_empty ((h RATHints)) bool
         (match h
                (RATHintsn tt)
                ((RATHintsc a b c) ff)))

; Insert into a CMap, preserving order
(program CMap_insert ((i mpz) (c clause) (cs CMap)) CMap
         (match cs
                (CMapn (CMapc i c CMapn))
                ((CMapc i' c' r)
                 (mp_ifneg (mpz_sub i i')
                        (CMapc i c cs)
                        (CMapc i' c' (CMap_insert i c r))))))

; Get from a CMap
(program CMap_get ((i mpz) (cs CMap)) clause
         (match cs
                (CMapn (fail clause))
                ((CMapc i' c r)
                 (mp_ifzero (mpz_sub i i')
                        c
                        (CMap_get i r)))))

; Remove from CMap. Only removes one element.
(program CMap_remove ((i mpz) (cs CMap)) CMap
         (match cs
                (CMapn CMapn)
                ((CMapc i' c r)
                 (mp_ifzero (mpz_sub i i')
                        r
                        (CMapc i' c (CMap_remove i r))))))

; Remove many indices from a CMap. Asuumes the input list is sorted.
(program CMap_remove_many ((is CIList) (cs CMap)) CMap
         (match
           is
           (CIListn cs)
           ((CIListc i is')
            (match
              cs
              (CMapn (fail CMap)) ; All deletion indices must be valid!
              ((CMapc ci c cs')
               (mp_ifzero (mpz_sub i ci)
                       (CMap_remove_many is' cs')
                       (CMapc ci c (CMap_remove_many is cs'))))))))

; Given a map of clauses and a literal, return all indices in the map
; corresponsing to clauses that could resolve against that literal. i.e. for x,
; return the indices of all clauses containing x.
(program collect_resolution_targets_w_lit ((cs CMap) (l lit)) CIList
         (match cs
                (CMapn CIListn)
                ((CMapc i c cs')
                 (let rest_solution (collect_resolution_targets_w_lit cs' l)
                   (match (clause_contains_lit c l)
                        (tt (CIListc i rest_solution))
                        (ff rest_solution))))))

; Given a clause and a maps of clauses, return all indices in the map
; corresponding to clauses which could resolve with this one on its first
; literal
(program collect_resolution_targets ((cs CMap) (c clause)) CIList
         (collect_resolution_targets_w_lit cs (lit_flip (clause_head c))))

; Is this clause a tautology?
; Internally uses mark 5 to flag variables that occur (+)
; and mark 6 to flag variables that occur (-)
(program is_t ((c clause)) bool
         (match
           c
           (cln ff)
           ((clc l c') (match
                         l
                         ((pos v)
                          (ifmarked5
                            v
                            (is_t c')
                            (ifmarked6
                              v
                              tt
                              (do
                                (markvar5 v)
                                (let r (is_t c') (do (markvar5 v) r))))))
                         ((neg v)
                          (ifmarked6
                            v
                            (is_t c')
                            (ifmarked5
                              v
                              tt
                              (do
                                (markvar6 v)
                                (let r (is_t c') (do (markvar6 v) r))))))))))

; ===================================================================== ;
; Programs for manipulating and querying the global variable assignment ;
; ===================================================================== ;

; This assignment marks values of type `var`.
; It marks a variable with 1 if that variable is true
; It marks a variable with 2 if that variable is false
; A variable should not be marked with both!
; A variable may be marked with neither, indicating that variable is presently
; unassigned, which we call "floating".

; Mark the variable within to satisfy this literal.
; fails if the literal is already UNSAT
(program lit_mk_sat ((l lit)) Unit
         (match l
                ((pos v) (ifmarked2 v
                                    (fail Unit)
                                    (ifmarked1 v unit (do (markvar1 v) unit))))
                ((neg v) (ifmarked1 v
                                    (fail Unit)
                                    (ifmarked2 v unit (do (markvar2 v) unit))))))

; Mark the variable within to falsify this literal.
; fails is the literal is already SAT
(program lit_mk_unsat ((l lit)) Unit
         (match l
                ((neg v) (ifmarked2 v
                                    (fail Unit)
                                    (ifmarked1 v unit (do (markvar1 v) unit))))
                ((pos v) (ifmarked1 v
                                    (fail Unit)
                                    (ifmarked2 v unit (do (markvar2 v) unit))))))

; Unmarks the variable within a satified literal to render it neither satified nor falsified
; fails if the literal is not already satisfied
(program lit_un_mk_sat ((l lit)) Unit
         (match l
                ((pos v) (ifmarked1 v (do (markvar1 v) unit) (fail Unit)))
                ((neg v) (ifmarked2 v (do (markvar2 v) unit) (fail Unit)))))

; Unmarks the variable within a falsified literal to render it neither satified nor falsified
; fails if the literal is not already falsified
(program lit_un_mk_unsat ((l lit)) Unit
         (match l
                ((pos v) (ifmarked2 v (do (markvar2 v) unit) (fail Unit)))
                ((neg v) (ifmarked1 v (do (markvar1 v) unit) (fail Unit)))))

;  Is a literal presently satisfied?
(program lit_is_sat ((l lit)) bool
         (match l
                ((pos v) (ifmarked1 v tt ff))
                ((neg v) (ifmarked2 v tt ff))))

;  Is a literal presently falsified?
(program lit_is_unsat ((l lit)) bool
         (match l
                ((pos v) (ifmarked2 v tt ff))
                ((neg v) (ifmarked1 v tt ff))))

;  Is a  literal presently neither satisfied nor falsified?
(program lit_is_floating ((l lit)) bool
         (bool_not (bool_or (lit_is_sat l) (lit_is_unsat l))))

; Does this clause contain a floating literal?
(program clause_has_floating ((c clause)) bool
         (match c
                (cln ff)
                ((clc l c') (match (lit_is_floating l)
                                   (tt tt)
                                   (ff (clause_has_floating c'))))))

; Is this clause falsified? i.e. are all its clauses falsified?
(program clause_is_unsat ((c clause)) bool
         (match c
                (cln tt)
                ((clc l c') (match (lit_is_unsat l)
                                   (tt (clause_is_unsat c'))
                                   (ff ff)))))

; Is this clause presently satisfied?
(program clause_is_sat ((c clause)) bool
         (match c
                (cln ff)
                ((clc l c') (match (lit_is_sat l)
                                   (tt tt)
                                   (ff (clause_is_sat c'))))))

; Falsify **all** contained literals.
; Fails on a tautological clause
(program clause_mk_all_unsat ((c clause)) Unit
         (match c
                (cln unit)
                ((clc l c') (do
                              (lit_mk_unsat l)
                              (clause_mk_all_unsat c')))))

; Unfalsifies **all** contained literals
; Fails on a clause with duplicate literals
(program clause_un_mk_all_unsat ((c clause)) Unit
         (match c
                (cln unit)
                ((clc l c') (do
                              (lit_un_mk_unsat l)
                              (clause_un_mk_all_unsat c')))))

; Get the first floating literal out of this clause.
; fails if there are no floating literals
(program clause_first_floating ((c clause)) lit
         (match c
                (cln (fail lit))
                ((clc l c') (match (lit_is_floating l)
                                   (tt l)
                                   (ff (clause_first_floating c'))))))

; ===================================== ;
; High-Level Programs for LRAT Checking ;
; ===================================== ;

; The return type for verifying that a clause is unit and modifying the global
; assignment to satisfy it
(declare MarkResult type)
; The clause is unit, and this is the (previoiusly floating) literal that is now satified.
(declare MRUnit (! l lit MarkResult))
; The clause was unsat!
(declare MRUnsat MarkResult)
; The clauss was already satisfied.
(declare MRSat MarkResult)
; The clause had multiple floating literals.
(declare MRNotUnit MarkResult)

; Determine wether this clause is sat, unsat, unit, or not unit, and if it is
; unit, it modifies the global assignment to satisfy the clause, and returns
; the literal that was made SAT by the new mark.
;
; If `c` is a tautology, reports `MRSat`, since it is (trivially) satisfied.
(program clause_check_unit_and_maybe_mark ((c clause)) MarkResult
         (match (clause_is_sat c)
                (tt MRSat)
                (ff (match (clause_is_unsat c)
                           (tt MRUnsat)
                           (ff (match (is_t c)
                                      (tt MRSat)
                                      (ff ; Dedent
         (match (clause_has_floating c)
                (tt (let first (clause_first_floating c)
                      (do (lit_mk_sat first)
                        (match (clause_has_floating c)
                               (tt (do (lit_un_mk_sat first) MRNotUnit))
                                      (ff (MRUnit first))))))
                ; Unreachable. If clause is not floating it must have been SAT or UNSAT.
                (ff (fail MarkResult))
                ))))))))

; The return type for the process of Trace-guided unit propegation
(declare UPResult type)
; The trace guided unit propegation correctly, but that unit propegation did not end in an empty clause
(declare UPR_Ok UPResult)
; The trace guided unit propegation correctly to an empty clause
(declare UPR_Bottom UPResult)
; The trace was malformed,
;; i.e. at some point indicates that a non-unit, non-empty clause should be examined
(declare UPR_Broken UPResult)

; Execute the unit propegation indicated by the trace. Report whether that
; unit propegation succeeds and produces bottom, fails, or succeeds but does
; not produce bottom.
;
; If the trace tries to propegate through a TAUT clause, fails.
(program do_up ((cs CMap) (t Trace)) UPResult
         (match
           t
           (Tracen UPR_Ok)
           ((Tracec i r) (match (clause_check_unit_and_maybe_mark (CMap_get i cs))
                                ((MRUnit l)
                                 (let res (do_up cs r)
                                   (do (lit_un_mk_sat l) res)))
                                (MRUnsat UPR_Bottom)
                                (MRSat UPR_Broken)
                                (MRNotUnit UPR_Broken)))))


; Determine whether a list of indices agrees with the list of indices latent in
; a list of hints. Both lists should be sorted.
(program resolution_targets_match (
                                   (computed CIList)
                                   (given RATHints)) bool
         (match given
                (RATHintsn
                  (match computed
                         (CIListn tt)
                         ((CIListc a b) ff)))
                ((RATHintsc hint_idx t given')
                 (match computed
                        ((CIListc comp_idx computed')
                         (mp_ifzero (mpz_sub hint_idx comp_idx)
                                    (resolution_targets_match computed' given')
                                    (ff)))
                        (CIListn ff)))))


; Determines whether `t` is a witness that `c` is an Assymetric Tautology in `cs`.
;
; Does unit propegation in the formula `cs`, beginning by falsifying
; all literals in `c`, and then looking at the clauses indicated by `t`.
; Assumes no marks, and cleans up marks afterwards.
;
; Fails if `c` has duplicates
(program is_at_trace ((cs CMap) (c clause) (t Trace)) UPResult
         (match (is_t c)
                (ff
                  (do
                    (clause_mk_all_unsat c)
                    (let result (do_up cs t)
                      (do (clause_un_mk_all_unsat c) result))))
                (tt
                  UPR_Bottom)))



; List of (clause, trace) pairs
(declare CTPairs type)
(declare CTPn CTPairs)
(declare CTPc (! c clause (! t Trace (! rest CTPairs CTPairs))))

; For each RAT hint, construct the pseudo-resolvant for that hint, and the net
; trace for that hint. Return a list of these.
;
; Pseudo resolvant: if l v C is the clause, and D is another clause containing
; ~l, then l v C v (D \ ~l) is the pseudo-resolvant, which is the actual
; resolant, plut l, which would be implied by UP.
;
; The net trace is the global trace (`t`), plut the trace for that specific
; resolvant.
(program construct_ct_pairs (
                             (cs CMap)
                             (c clause)
                             (t Trace)
                             (hints RATHints)
                            ) CTPairs
         (match hints
                (RATHintsn CTPn)
                ((RATHintsc i ht hints')
                 (CTPc
                   (clause_dedup (clause_append c
                                  (clause_remove_all (lit_flip (clause_head c))
                                                     (CMap_get i cs))))
                   (Trace_concat t ht)
                   (construct_ct_pairs cs c t hints')))))

; Goes through a list of clause, trace pairs and verifies that each clause is
; an AT via that trace.
; Fails if any putative AT is a TAUT or contains duplicates
(program are_all_at_trace (
                     (cs CMap)
                     (l CTPairs)
                    ) UPResult
         (match l
                (CTPn UPR_Bottom)
                ((CTPc c t l')
                 (match (is_at_trace cs c t)
                        (UPR_Ok UPR_Ok)
                        (UPR_Broken UPR_Broken)
                        (UPR_Bottom (are_all_at_trace cs l'))))))

; Is this trace, and list of hints, proof that `c` is an Resolution Assymeytic
; Tautology?
; Fails is the hints are empty (which means `c` should  be AT) and `c` contains
; duplicates)
(program is_rat_trace ((cs CMap) (c clause) (t Trace) (hints RATHints)) UPResult
         (match
           (RATHints_is_empty hints)
           (tt ; Empty RAT hints -- the clause must be AT
             (is_at_trace cs c t))
           (ff ; Ew -- we must verify this is a RAT
             (match (resolution_targets_match
                      (collect_resolution_targets cs c)
                      hints)
                    (ff ; Resolution targets disagree with hints.
                      UPR_Broken)
                    (tt
                      (are_all_at_trace cs (construct_ct_pairs cs c t hints)))))))

; Is this proof an LRAT proof of bottom?
; Fails if any added AT is a TAUT or contains duplicates OR if any added RAT
; produces pseudo-resolvants which are TAUT or contain duplicates
(program is_lrat_proof_of_bottom ((f CMap) (proof LRATProof)) bool
         (match proof
                ((LRATProofd indices rest)
                 (is_lrat_proof_of_bottom
                   (CMap_remove_many indices f)
                   rest))
                ((LRATProofa idx c trace hints rest)
                 (match (is_rat_trace f c trace hints)
                    (UPR_Bottom
                      (match
                        c
                        (cln tt)
                        ((clc a b)
                         (is_lrat_proof_of_bottom (CMap_insert idx c f) rest))))
                    (UPR_Ok ff)
                    (UPR_Broken ff)))
                (LRATProofn ff))
         )


; Proof of a CMap from clause proofs.
; The idx is unelidable b/c it is unspecified.
;  Robust against clauses with duplicat literals, but not against tautological
;  clauses.
(declare CMap_holds (! c CMap type))
(declare CMapn_proof (CMap_holds CMapn))
(declare CMapc_proof
         (! idx mpz ; Not elidable!
            (! c clause
               (! deduped_c clause
                  (! rest CMap
                     (! proof_c (holds c)
                        (! proof_rest (CMap_holds rest)
                            (! sc (^ (clause_dedup c) deduped_c)
                               (CMap_holds (CMapc idx deduped_c rest))))))))))

(define bottom (holds cln))
(declare lrat_proof_of_bottom
         (! cm CMap
            (! proof_cm (CMap_holds cm)
               (! proof LRATProof
                  (! sc (^ (is_lrat_proof_of_bottom cm proof) tt)
                     bottom)))))


; TODO(aozdemir) Reducing the amount of checking that resides in side-conditions.
; Steps
;  1. Unroll the traversal of is_lrat_proof_of_bottom into a serialized
;     sequence of axiom applications.
;     The axioms would likely correspond to DELETE, IS T, IS AT, IS RAT.
;     They would manipulate a CMap by way of side-conditions.
;  2. Unroll AT checks by manifesting the assignment in data rather than marks,
;     and having axioms like IS_UNSAT, IS_UNIT_ON_LITERAL.
;  3. Unroll RAT checks in a similar fashion, although more painfully.
; Depends on lrat.plf
;
; Implementation of DRAT checking.
;
; Unfortunately, there are **two** different notions of DRAT floating around in
; the world:
;   * Specified   DRAT : This is a reasonable proof format
;   * Operational DRAT : This is a variant of specified DRAT warped by the
;                        details of common SAT solver architectures.
;
; Both are detailed in this paper, along with their differences:
;   http://fmv.jku.at/papers/RebolaPardoBiere-POS18.pdf
;
; This signature contains implementations for a checker for each.
; **Specified DRAT** is first.

; A DRAT proof itself: a list of addition or deletion instructions.
(declare DRATProof type)
(declare DRATProofn DRATProof)
(declare DRATProofa (! c clause (! p DRATProof DRATProof)))
(declare DRATProofd (! c clause (! p DRATProof DRATProof)))

; ==================== ;
; Functional  Programs ;
; ==================== ;

; Are two clauses equal (i.e., if interpretted as sets of literals, are those
; sets equal?)
;
; Assumes that marks 1,2,3,4 are clear for the constituent variables, and
; leaves them clear afterwards.
;
; Since clauses are sets, it is insufficient to do list equality.
; We could sort them, but that would require defining an order on our variables,
; and incurring the cost of sorting.
;
;
; Instead, we do the following:
;  1. Sweep the first clause, marking variables with flags 1,3 (pos) and 2,4 (neg)
;  2. Sweep the second clause, erasing marks 1,2. Returning FALSE if no mark 3,4.
;  3. Unsweep the first clause, returning FALSE on marks 1,2.
;     Also unmarking 3,4, and 1,2 if needed
;
; So the mark 1 means (seen as + in c1, but not yet in c2)
;    the mark 3 means (seen as + in c1)
;    the mark 2 means (seen as - in c1, but not yet in c2)
;    the mark 4 means (seen as - in c1)
;
; This implementation **does not**:
;    1. assume that clauses do not have duplicates
;       (so the clause [x v x v ~y] is an accceptable input)
;    2. assume that clauses are non-tautological
;       (so the clause [x v ~x] is an acceptable input)
;
; TODO(aozdemir) This implementation could be further optimized b/c once c1 is
; drained, we need not continue to pattern match on it.
(program clause_eq ((c1 clause) (c2 clause)) bool
         (match
           c1
           (cln (match
                  c2
                  (cln tt)
                  ((clc c2h c2t) (match
                                   c2h
                                   ((pos v)
                                    (ifmarked1
                                      v
                                      (do (markvar1 v)
                                        (clause_eq c1 c2t))
                                      (ifmarked3
                                        v
                                        (clause_eq c1 c2t)
                                        ff)))
                                   ((neg v)
                                    (ifmarked2
                                      v
                                      (do (markvar2 v)
                                        (clause_eq c1 c2t))
                                      (ifmarked4
                                        v
                                        (clause_eq c1 c2t)
                                        ff)))))))
           ((clc c1h c1t) (match
                            c1h
                            ((pos v)
                             (ifmarked3
                               v
                               (clause_eq c1t c2)
                               (do (markvar3 v)
                                 (do (markvar1 v)
                                   (let res (clause_eq c1t c2)
                                     (do (markvar3 v)
                                       (ifmarked1
                                         v
                                         (do (markvar1 v) ff)
                                         res)))))))
                            ((neg v)
                             (ifmarked4
                               v
                               (clause_eq c1t c2)
                               (do (markvar4 v)
                                 (do (markvar2 v)
                                   (let res (clause_eq c1t c2)
                                     (do (markvar4 v)
                                       (ifmarked2
                                         v
                                         (do (markvar2 v) ff)
                                         res)))))))))))


; Does this formula contain bottom as one of its clauses?
(program cnf_has_bottom ((cs cnf)) bool
         (match cs
                (cnfn ff)
                ((cnfc c rest) (match c
                                      (cln tt)
                                      ((clc l c') (cnf_has_bottom rest))))))

; Return a new cnf with one copy of this clause removed.
; If the clause is absent, returns the original cnf.
(program cnf_remove_clause ((c clause) (cs cnf)) cnf
         (match cs
                (cnfn cnfn)
                ((cnfc c' cs')
                 (match (clause_eq c c')
                        (tt cs')
                        (ff (cnfc c' (cnf_remove_clause c cs')))))))

; return (c1 union (c2 \ ~l))
; Significant for how a RAT is defined.
(program clause_pseudo_resolvent ((c1 clause) (c2 clause)) clause
         (clause_dedup (clause_append c1
                                      (clause_remove_all
                                        (lit_flip (clause_head c1)) c2))))

; Given a formula, `cs` and a clause `c`, return all pseudo resolvents, i.e. all
;     (c union (c' \ ~head(c)))
;   for c' in cs, where c' contains ~head(c)
(program collect_pseudo_resolvents ((cs cnf) (c clause)) cnf
         (match cs
                (cnfn cnfn)
                ((cnfc c' cs')
                 (let rest_of_resolvents (collect_pseudo_resolvents cs' c)
                   (match (clause_contains_lit c' (lit_flip (clause_head c)))
                          (tt (cnfc (clause_pseudo_resolvent
                                      c
                                      c')
                                    rest_of_resolvents))
                          (ff rest_of_resolvents))))))

; =============================================================== ;
; Unit Propegation implementation (manipulates global assignment) ;
; =============================================================== ;
; See the lrat file for a description of the global assignment.

; The result of search for a unit clause in
(declare UnitSearchResult type)
; There was a unit, and
;    this is the (previously floating) literal that is now satisfied.
;    this is a version of the input cnf with satisfied clauses removed.
(declare USRUnit (! l lit (! f cnf UnitSearchResult)))
; There was an unsat clause
(declare USRBottom UnitSearchResult)
; There was no unit.
(declare USRNoUnit UnitSearchResult)

; If a UnitSearchResult is a Unit, containing a cnf, adds this clause to that
; cnf. Otherwise, returns the UnitSearchResult unmodified.
(program USR_add_clause ((c clause) (usr UnitSearchResult)) UnitSearchResult
         (match usr
                ((USRUnit l f) (USRUnit l (cnfc c f)))
                (USRBottom USRBottom)
                (USRNoUnit USRNoUnit)))

; Searches through the clauses, looking for a unit clause.
; Reads the global assignment. Possibly assigns one variable.
;  Returns
;    USRBottom     if there is an unsat clause
;    (USRUnit l f) if there is a unit, with lit l, and
;                  f is the cnf with some SAT clauses removed.
;    USRNoUnit     if there is no unit
(program unit_search ((f cnf)) UnitSearchResult
         (match f
                (cnfn USRNoUnit)
                ((cnfc c f')
                 (match (clause_check_unit_and_maybe_mark c)
                        (MRSat (unit_search f'))
                        ((MRUnit l) (USRUnit l f'))
                        (MRUnsat USRBottom)
                        (MRNotUnit (USR_add_clause c (unit_search f')))))))


; Given the current global assignment, does the formula `f` imply bottom via
; unit propegation? Leaves the global assignment in the same state that it was
; initially.
(program unit_propegates_to_bottom ((f cnf)) bool
         (match (unit_search f)
                (USRBottom tt)
                ((USRUnit l f') (let result (unit_propegates_to_bottom f')
                               (do (lit_un_mk_sat l)
                                 result)))
                (USRNoUnit ff)))

; ================================== ;
; High-Level DRAT checking functions ;
; ================================== ;

; Is this clause an AT?
(program is_at ((cs cnf) (c clause)) bool
         (match (is_t c)
                (tt tt)
                (ff (do (clause_mk_all_unsat c)
                      (let r (unit_propegates_to_bottom cs)
                        (do (clause_un_mk_all_unsat c)
                          r))))))

; Are all of these clauses ATs?
(program are_all_at ((cs cnf) (clauses cnf)) bool
         (match clauses
                (cnfn tt)
                ((cnfc c clauses')
                 (match (is_at cs c)
                        (tt (are_all_at cs clauses'))
                        (ff ff)))))

; Is the clause `c` a RAT for the formula `cs`?
(program is_rat ((cs cnf) (c clause)) bool
         (match (is_t c)
                (tt tt)
                (ff (match (is_at cs c)
                           (tt tt)
                           (ff (match c
                                      (cln ff)
                                      ((clc a b) (are_all_at ; dedent
                                 cs
                                 (collect_pseudo_resolvents cs c)))))))))

; Is this proof a valid DRAT proof of bottom?
(program is_specified_drat_proof ((f cnf) (proof DRATProof)) bool
         (match proof
                (DRATProofn (cnf_has_bottom f))
                ((DRATProofa c p) (match
                                    (is_rat f c)
                                    (tt (is_specified_drat_proof (cnfc c f) p))
                                    (ff ff)))
                ((DRATProofd c p)
                 (is_specified_drat_proof (cnf_remove_clause c f) p))))


; =============================== ;
; Operational DRAT implementation ;
; =============================== ;

; Operation DRAT is defined in the paper "Two Flavors of DRAT".
; Below is an extension of the DRAT signature to handle it.

; Notes on types.
; For operational DRAT it is useful to manifest partial assignments in values
; (although we still use the global assignment in some places). To this end,
; literals are used to represent single-variable assignments ((pos v) denotes
; {v maps to true}) and clauses are partial assignments by way of being
; literal lists.

; Copy the partial assignment represented by a clause into the global
; assignment. Fails if that clause represents an inconsistent partial
; assignment (e.g. v is both true and false)
(program clause_into_global ((a clause)) Unit
         (match a
                (cln unit)
                ((clc l rest)
                 (do (lit_mk_sat l) (clause_into_global rest)))))

; Remove the partial assignment represented by c from the global assignment
(program clause_undo_into_global ((a clause)) Unit
         (match a
                (cln unit)
                ((clc l rest)
                 (do (lit_un_mk_sat l) (clause_undo_into_global rest)))))

; Does this clause have no floating literals w.r.t. the global assignment?
(program clause_no_floating ((c clause)) bool
         (match c
                (cln tt)
                ((clc l rest) (match (lit_is_floating l)
                                    (tt ff)
                                    (ff (clause_no_floating rest))))))

; Does this clause have no sat literals w.r.t. the global assignment?
(program clause_no_sat ((c clause)) bool
         (match c
                (cln tt)
                ((clc l rest) (match (lit_is_sat l)
                                    (tt ff)
                                    (ff (clause_no_sat rest))))))

; Does this clause have one sat literal w.r.t. the global assignment?
(program clause_one_sat ((c clause)) bool
         (match c
                (cln ff)
                ((clc l rest) (match (lit_is_sat l)
                                    (tt (clause_no_sat rest))
                                    (ff (clause_one_sat rest))))))

; Is this clause a unit clause w.r.t. the global assignment?
; This notion is defined as:
;    * A clause where no literals are floating, and exactly one is sat.
(program clause_is_unit_wrt_up_model ((c clause) (up_model clause)) bool
         (let c' (clause_dedup c)
         (do (clause_into_global up_model)
           (let result (match (clause_no_floating c')
                              (tt (clause_one_sat c'))
                              (ff ff))
             (do (clause_undo_into_global up_model)
               result)))))

; Result from constructing a UP model (defined in "Two Flavors of DRAT")
; Technically, we're constructing the shared UP model -- the intersection of all
; UP models.
; Informally, this is just the partial assignment implied by UP.
;
; This type is necessary, because constructing a UP model can reveal an
; inconsistent UP model -- one which assigns some variable to true and false.
; This would break our machinery, so we special case it.
(declare UPConstructionResult type)
; An actual model
(declare UPCRModel (! up_model clause UPConstructionResult))
; Bottom is implied!
(declare UPCRBottom UPConstructionResult)


; Do unit propagation on `f`, constructing a UP model for it.
(program build_up_model ((f cnf)) UPConstructionResult
         (match (unit_search f)
                (USRBottom UPCRBottom)
                (USRNoUnit (UPCRModel cln))
                ((USRUnit l f')
                 (let result (build_up_model f')
                   (do (lit_un_mk_sat l)
                     (match result
                            (UPCRBottom UPCRBottom)
                            ((UPCRModel model) (UPCRModel (clc l model)))))))))

; Given some starting assignment (`up_model`), continue UP to construct a larger
; model.
(program extend_up_model ((f cnf) (up_model clause)) UPConstructionResult
         (do (clause_into_global up_model)
           (let result (build_up_model f)
             (do (clause_undo_into_global up_model)
               (match result
                      (UPCRBottom UPCRBottom)
                      ((UPCRModel up_model')
                       (UPCRModel (clause_append up_model up_model'))))))))

; Helper for `is_operational_drat_proof` which takes a UP model for the working
; formula. The UP model is important for determining which clause deletions
; actually are executed in operational DRAT. Passing the UP model along
; prevents it from being fully recomputed everytime.
(program is_operational_drat_proof_h ((f cnf) (up_model clause) (pf DRATProof)) bool
         (match pf
                (DRATProofn (cnf_has_bottom f))
                ((DRATProofd c pf')
                 (match (clause_is_unit_wrt_up_model c up_model)
                        (tt (is_operational_drat_proof_h f up_model pf'))
                        (ff (is_operational_drat_proof_h
                              (cnf_remove_clause c f) up_model pf'))))
                ((DRATProofa c pf')
                 (let f' (cnfc c f)
                   (match (is_rat f c)
                          (tt (match (extend_up_model f' up_model)
                                     (UPCRBottom tt)
                                     ((UPCRModel up_model')
                                      (is_operational_drat_proof_h f' up_model' pf'))))
                          (ff ff))))))

; Is this an operational DRAT proof of bottom for this formula?
(program is_operational_drat_proof ((f cnf) (pf DRATProof)) bool
         (match (build_up_model f)
                (UPCRBottom tt)
                ((UPCRModel model) (is_operational_drat_proof_h f model pf))))

; Is this a specified or operational DRAT proof of bottom for this formula?
(program is_drat_proof ((f cnf) (pf DRATProof)) bool
         (match (is_specified_drat_proof f pf)
                (tt tt)
                (ff (is_operational_drat_proof f pf))))

(declare drat_proof_of_bottom
         (! f cnf
            (! proof_of_formula (cnf_holds f)
               (! proof DRATProof
                  (! sc (^ (is_drat_proof f proof) tt)
                     bottom)))))

; Depends on sat.plf

; This file exists to support the **definition introduction** (or **extension**)
; rule in the paper:
;  "Extended Resolution Simulates DRAT"
; which can be found at http://www.cs.utexas.edu/~marijn/publications/ijcar18.pdf
;
; The core idea of extended resolution is that given **any** formula f
; involving the variables from some SAT problem, one can introduce the
; constraint
;
;    new <=> f
;
; without changing satisfiability, where "new" is a fresh variable.
;
; This signature does not provide axioms for facilitating full use of this
; idea. Instead, this signature facilitates use of one specific kind of
; extension, that of the form:
;
;     new <=> old v (~l_1 ^ ~l_2 ^ ... ^ ~l_n)
;
; which translates into the clauses:
;
;                      new v l_1 v l_2 v ... v l_n
;                      new v ~old
;     for each i <= n: l_i v ~new v old
;
; This kind of extension is (a) sufficient to simulate DRAT proofs and (b) easy
; to convert to clauses, which is why we use it.

; A definition witness value for:
;              new <=> old v (~others_1 ^ ~others_2 ^ ... ^ ~others_n)
; It witnesses the fact that new was fresh when it was defined by the above.
;
; Thus it witnesses that the above, when added to the formula consisting of the
; conjunction all the already-proven clauses, produces an equisatisfiable
; formula.
(declare definition (! new var (! old lit (! others clause type))))

; Given `old` and `others`, this takes a continuation which expects
;      1. a fresh variable `new`
;      2. a definition witness value for:
;              new <=> old v (~others_1 ^ ~others_2 ^ ... ^ ~others_n)
;
; Aside:
;    In programming a **continuation** of some computation is a function that
;    takes the results of that computation as arguments to produce a final
;    result.
;
;    In proof-construction a **continuation** of some reasoning is a function
;    that takes the results of that reasoning as arguments to proof a final
;    result.
;
; That definition witness value can be clausified using the rule below.
;
; There need to be two different rules because the side-condition for
; clausification needs access to the new variable, which doesn't exist except
; inside the continuation, which is out-of-scope for any side-condition
; associated with this rule.
(declare decl_definition
         (! old lit
            (! others clause ; List of vars
               (! pf_continuation (! new var (! def (definition new old others)
                                           (holds cln)))
                  (holds cln)))))

; Represents multiple conjoined clauses.
; There is a list, `heads` of literals, each of which is suffixed by the
; same `tail`.
(declare common_tail_cnf_t type)
(declare common_tail_cnf
         (! heads clause
         (! tail  clause common_tail_cnf_t)))

; A member of this type is a proof of a common_tail_cnf.
(declare common_tail_cnf_holds
         (! cnf common_tail_cnf_t type))

; This translates a definition witness value for the def:
;
;    new <=> old v (~l_1 ^ ~l_2 ^ ... ^ ~l_n)
;
; into the clauses:
;
;                      new v l_1 v l_2 v ... v l_n
;                      new v ~old
;     for each i <= n: l_i v ~new v old              (encoded as (cnf_holds ...))
(declare clausify_definition
         (! new var
         (! old lit
         (! others clause
         ; Given a definition { new <-> old v (~l_1 ^ ~l_2 ^ ... ^ ~l_n) }
         (! def (definition new old others)
         (! negOld lit
         (! mkNegOld (^ (lit_flip old) negOld)
         ; If you can prove bottom from its clausal representation
         (! pf_continuation
            ; new v l_1 v l_2 v ... v l_n
            (! pf_c1 (holds (clc (pos new) others))
               ; new v ~old
               (! pf_c2 (holds (clc (pos new) (clc negOld cln)))
                  ; for each i <= n: l_i v ~new v old
                  (! pf_cs (common_tail_cnf_holds
                             (common_tail_cnf
                               others
                               (clc (neg new) (clc old cln))))
                     (holds cln))))
         ; Then you've proven bottom
         (holds cln)))))))))

; These axioms are useful for converting a proof of some CNF formula represented
; using the `common_tail_cnf` type (a value of type `common_tail_cnf_holds`),
; into proofs of its constituent clauses (many values of type `holds`).
; Given
;    1. a proof of some `common_tail_cnf`
; Then
;    1. the first axiom gives you a proof of the first `clause` therein and
;    2. the second gives you a proof of the rest of the `common_tail_cnf`.
(declare common_tail_cnf_prove_head
         (! first lit
         (! rest clause
         (! tail clause
         (! pf (common_tail_cnf_holds (common_tail_cnf (clc first rest) tail))
            (holds (clc first tail)))))))
(declare common_tail_cnf_prove_tail
         (! first lit
         (! rest clause
         (! tail clause
         (! pf (common_tail_cnf_holds (common_tail_cnf (clc first rest) tail))
            (common_tail_cnf_holds (common_tail_cnf rest tail)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Theory of Equality and Congruence Closure
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; depends on : smt.plf

; sorts :

(declare arrow (! s1 sort (! s2 sort sort)))	; function constructor

; functions :

(declare apply (! s1 sort
               (! s2 sort
               (! t1 (term (arrow s1 s2))
               (! t2 (term s1)
                (term s2))))))


; inference rules :

(declare trust (th_holds false))	; temporary
(declare trust_f (! f formula (th_holds f)))  ; temporary

(declare refl
  (! s sort
  (! t (term s)
    (th_holds (= s t t)))))

(declare symm (! s sort
              (! x (term s)
              (! y (term s)
              (! u (th_holds (= s x y))
                (th_holds (= s y x)))))))

(declare trans (! s sort
               (! x (term s)
               (! y (term s)
               (! z (term s)
               (! u (th_holds (= s x y))
               (! u (th_holds (= s y z))
                 (th_holds (= s x z)))))))))

(declare negsymm (! s sort
              	 (! x (term s)
              	 (! y (term s)
              	 (! u (th_holds (not (= s x y)))
                   (th_holds (not (= s y x))))))))

(declare negtrans1 (! s sort
                   (! x (term s)
              	   (! y (term s)
               	   (! z (term s)
               	   (! u (th_holds (not (= s x y)))
               	   (! u (th_holds (= s y z))
                     (th_holds (not (= s x z))))))))))

(declare negtrans2 (! s sort
                   (! x (term s)
              	   (! y (term s)
               	   (! z (term s)
               	   (! u (th_holds (= s x y))
               	   (! u (th_holds (not (= s y z)))
                     (th_holds (not (= s x z))))))))))

(declare cong (! s1 sort
              (! s2 sort
              (! a1 (term (arrow s1 s2))
              (! b1 (term (arrow s1 s2))
              (! a2 (term s1)
              (! b2 (term s1)
              (! u1 (th_holds (= (arrow s1 s2) a1 b1))
              (! u2 (th_holds (= s1 a2 b2))
                (th_holds (= s2 (apply s1 s2 a1 a2) (apply s1 s2 b1 b2))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Examples

; an example of "(p1 or p2(0)) and t1=t2(1)"
;(! p1 (term Bool)
;(! p2 (term (arrow Int Bool))
;(! t1 (term Int)
;(! t2 (term (arrow Int Int))
;(! F (th_holds (and (or (p_app p1) (p_app (apply _ _ p2 0)))
;                    (= _ t1 (apply _ _ t2 1))))
;  ...

; another example of "p3(a,b)"
;(! a (term Int)
;(! b (term Int)
;(! p3 (term (arrow Int (arrow Int Bool)))	; arrow is right assoc.
;(! F (th_holds (p_app (apply _ _ (apply _ _ p3 a) b))) ; apply is left assoc.
;  ...
;;;; TEMPORARY:

(declare trust-bad (th_holds false))

; helper stuff

(program mpz_ ((x mpz) (y mpz)) formula
    (mp_ifzero (mpz_sub x y) true false))


; "bitvec" is a term of type "sort"
; (declare BitVec sort)
(declare BitVec (!n mpz sort))

; bit type
(declare bit type)
(declare b0 bit)
(declare b1 bit)

; bit vector type used for constants
(declare bv type)
(declare bvn bv)
(declare bvc (! b bit (! v bv bv)))

; calculate the length of a bitvector
;; (program bv_len ((v bv)) mpz
;;   (match v
;;     (bvn 0)
;;     ((bvc b v') (mp_add (bv_len v') 1))))


; a bv constant term
(declare a_bv
	 (! n mpz
	 (! v bv
	    (term (BitVec n)))))

(program bv_constants_are_disequal ((x bv) (y bv)) formula
  (match x
      (bvn (fail formula))
      ((bvc bx x')
        (match y
          (bvn (fail formula))
          ((bvc by y') (match bx
                             (b0 (match by (b0 (bv_constants_are_disequal x' y')) (b1 (true))))
                             (b1 (match by (b0 (true)) (b1 (bv_constants_are_disequal x' y'))))
          ))
      ))
))

(declare bv_disequal_constants
	 (! n mpz
	 (! x bv
	 (! y bv
	 (! c (^ (bv_constants_are_disequal x y) true)
  	   (th_holds (not (= (BitVec n) (a_bv n x) (a_bv n y)))))))))

; a bv variable
(declare var_bv type)
; a bv variable term
(declare a_var_bv
	 (! n mpz
	 (! v var_bv
	    (term (BitVec n)))))

; bit vector binary operators
(define bvop2
	(! n mpz
	(! x (term (BitVec n))
        (! y (term (BitVec n))
             	   (term (BitVec n))))))

(declare bvand bvop2)
(declare bvor bvop2)
(declare bvor bvop2)
(declare bvxor bvop2)
(declare bvnand bvop2)
(declare bvnor bvop2)
(declare bvxnor bvop2)
(declare bvmul bvop2)
(declare bvadd bvop2)
(declare bvsub bvop2)
(declare bvudiv bvop2)
(declare bvurem bvop2)
(declare bvsdiv bvop2)
(declare bvsrem bvop2)
(declare bvsmod bvop2)
(declare bvshl bvop2)
(declare bvlshr bvop2)
(declare bvashr bvop2)
(declare concat bvop2)

; bit vector unary operators
(define bvop1
	(! n mpz
	(! x (term (BitVec n))
             	   (term (BitVec n)))))


(declare bvneg bvop1)
(declare bvnot bvop1)
(declare rotate_left  bvop1)
(declare rotate_right bvop1)

(declare bvcomp
	 (! n mpz
 	 (! t1 (term (BitVec n))
	 (! t2 (term (BitVec n))
	    (term (BitVec 1))))))


(declare concat
	 (! n mpz
	 (! m mpz
	 (! m' mpz
	 (! t1 (term (BitVec m))
	 (! t2 (term (BitVec m'))
	    (term (BitVec n))))))))

;; side-condition fails in signature only??
;;	 (! s (^ (mp_add m m') n)

;; (declare repeat bvopp)

(declare extract
	 (! n mpz
	 (! i mpz
	 (! j mpz
	 (! m mpz
	 (! t2 (term (BitVec m))
	    (term (BitVec n))))))))

(declare zero_extend
	 (! n mpz
	 (! i mpz
	 (! m mpz
	 (! t2 (term (BitVec m))
	    (term (BitVec n)))))))

(declare sign_extend
	 (! n mpz
	 (! i mpz
	 (! m mpz
	 (! t2 (term (BitVec m))
	    (term (BitVec n)))))))

(declare repeat
	 (! n mpz
	 (! i mpz
	 (! m mpz
	 (! t2 (term (BitVec m))
	    (term (BitVec n)))))))



;; TODO: add checks for valid typing for these operators
;; (! c1 (^ (mpz_lte i j)
;; (! c2 (^ (mpz_lt i n) true)
;; (! c3 (^ (mp_ifneg i false true) true)
;; (! c4 (^ (mp_ifneg j false true) true)
;; (! s (^ (mp_add (mpz_sub i j) 1) m)


; bit vector predicates
(define bvpred
	(! n mpz
	(! x (term (BitVec n))
	(! y (term (BitVec n))
	           formula))))

(declare bvult bvpred)
(declare bvule bvpred)
(declare bvugt bvpred)
(declare bvuge bvpred)
(declare bvslt bvpred)
(declare bvsle bvpred)
(declare bvsgt bvpred)
(declare bvsge bvpred)
; bit blasted terms as list of formulas
(declare bblt type)
(declare bbltn bblt)
(declare bbltc (! f formula (! v bblt bblt)))

; calculate the length of a bit-blasted term
(program bblt_len ((v bblt)) mpz
  (match v
    (bbltn 0)
    ((bbltc b v') (mp_add (bblt_len v') 1))))


; (bblast_term x y) means term y corresponds to bit level interpretation x
(declare bblast_term
	 (! n mpz
	 (! x (term (BitVec n))
	 (! y bblt
	    type))))

; FIXME: for unsupported bit-blast terms
(declare trust_bblast_term
	 (! n mpz
	 (! x (term (BitVec n))
	 (! y bblt
	    (bblast_term n x y)))))


; Binds a symbol to the bblast_term to be used later on.
(declare decl_bblast
	 (! n mpz
	 (! b bblt
	 (! t (term (BitVec n))
	 (! bb (bblast_term n t b)
	 (! s (^ (bblt_len b) n)
	 (! u (! v (bblast_term n t b) (holds cln))
		   (holds cln))))))))

(declare decl_bblast_with_alias
	 (! n mpz
	 (! b bblt
	 (! t (term (BitVec n))
	 (! a (term (BitVec n))
	 (! bb (bblast_term n t b)
	 (! e (th_holds (= (BitVec n) t a))
	 (! s (^ (bblt_len b) n)
	 (! u (! v (bblast_term n a b) (holds cln))
		   (holds cln))))))))))

; a predicate to represent the n^th bit of a bitvector term
(declare bitof
	 (! x var_bv
	 (! n mpz formula)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;           BITBLASTING RULES
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST CONSTANT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_const ((v bv) (n mpz)) bblt
  (mp_ifneg n (match v (bvn bbltn)
                       (default (fail bblt)))
              (match v ((bvc b v') (bbltc (match b (b0 false) (b1 true)) (bblast_const v' (mp_add n (~ 1)))))
                       (default (fail bblt)))))

(declare bv_bbl_const (! n mpz
                      (! f bblt
                      (! v bv
                      (! c (^ (bblast_const v (mp_add n (~ 1))) f)
                           (bblast_term n (a_bv n v) f))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST VARIABLE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_var ((x var_bv) (n mpz)) bblt
  (mp_ifneg n bbltn
              (bbltc (bitof x n) (bblast_var x (mp_add n (~ 1))))))

(declare bv_bbl_var (! n mpz
                    (! x var_bv
                    (! f bblt
                    (! c (^ (bblast_var x (mp_add n (~ 1))) f)
                         (bblast_term n (a_var_bv n x) f))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST CONCAT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_concat ((x bblt) (y bblt)) bblt
  (match x
    (bbltn (match y ((bbltc by y') (bbltc by (bblast_concat x y')))
    	   	    (bbltn bbltn)))
    ((bbltc bx x') (bbltc bx (bblast_concat x' y)))))

(declare bv_bbl_concat (! n mpz
	 	       (! m mpz
		       (! m1 mpz
                       (! x (term (BitVec m))
		       (! y (term (BitVec m1))
		       (! xb bblt
		       (! yb bblt
		       (! rb bblt
		       (! xbb (bblast_term m x xb)
		       (! ybb (bblast_term m1 y yb)
                       (! c (^ (bblast_concat xb yb ) rb)
                           (bblast_term n (concat n m m1 x y) rb)))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST EXTRACT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_extract_rec ((x bblt) (i mpz) (j mpz) (n mpz)) bblt
  (match x
    ((bbltc bx x') (mp_ifneg (mpz_sub (mpz_sub j n) 1)
    	       	   	     (mp_ifneg (mpz_sub (mpz_sub n i) 1)
			    	  	  (bbltc bx (bblast_extract_rec x' i j (mpz_sub n 1)))
					  (bblast_extract_rec x' i j (mpz_sub n 1)))

			     bbltn))
   (bbltn bbltn)))

(program bblast_extract ((x bblt) (i mpz) (j mpz) (n mpz)) bblt
 (bblast_extract_rec x i j (mpz_sub n 1)))

(declare bv_bbl_extract (! n mpz
			(! i mpz
			(! j mpz
			(! m mpz
                       	(! x (term (BitVec m))
		       	(! xb bblt
		       	(! rb bblt
		       	(! xbb (bblast_term m x xb)
			(! c ( ^ (bblast_extract xb i j m) rb)
                           (bblast_term n (extract n i j m x) rb)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST ZERO/SIGN EXTEND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program extend_rec ((x bblt) (i mpz) (b formula)) bblt
  (mp_ifneg i x
  	    (bbltc b (extend_rec x (mpz_sub i 1) b))))

(program bblast_zextend ((x bblt) (i mpz)) bblt
 (extend_rec x (mpz_sub i 1) false))

(declare bv_bbl_zero_extend (! n mpz
			(! k mpz
			(! m mpz
                       	(! x (term (BitVec m))
		       	(! xb bblt
		       	(! rb bblt
		       	(! xbb (bblast_term m x xb)
			(! c ( ^ (bblast_zextend xb k) rb)
                           (bblast_term n (zero_extend n k m x) rb))))))))))

(program bblast_sextend ((x bblt) (i mpz)) bblt
 (match x (bbltn (fail bblt))
 	  ((bbltc xb x') (extend_rec x (mpz_sub i 1) xb))))

(declare bv_bbl_sign_extend (! n mpz
			(! k mpz
			(! m mpz
                       	(! x (term (BitVec m))
		       	(! xb bblt
		       	(! rb bblt
		       	(! xbb (bblast_term m x xb)
			(! c ( ^ (bblast_sextend xb k) rb)
                           (bblast_term n (sign_extend n k m x) rb))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_bvand ((x bblt) (y bblt)) bblt
  (match x
    (bbltn (match y (bbltn bbltn) (default (fail bblt))))
    ((bbltc bx x') (match y
                      (bbltn (fail bblt))
                      ((bbltc by y') (bbltc (and bx by) (bblast_bvand x' y')))))))

(declare bv_bbl_bvand (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvand xb yb ) rb)
                           (bblast_term n (bvand n x y) rb)))))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVNOT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_bvnot ((x bblt)) bblt
  (match x
    (bbltn bbltn)
    ((bbltc bx x') (bbltc (not bx) (bblast_bvnot x')))))

(declare bv_bbl_bvnot (! n mpz
                      (! x (term (BitVec n))
		      (! xb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
                      (! c (^ (bblast_bvnot xb ) rb)
                           (bblast_term n (bvnot n x) rb))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_bvor ((x bblt) (y bblt)) bblt
  (match x
    (bbltn (match y (bbltn bbltn) (default (fail bblt))))
    ((bbltc bx x') (match y
                      (bbltn (fail bblt))
                      ((bbltc by y') (bbltc (or bx by) (bblast_bvor x' y')))))))

(declare bv_bbl_bvor (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvor xb yb ) rb)
                           (bblast_term n (bvor n x y) rb)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVXOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_bvxor ((x bblt) (y bblt)) bblt
  (match x
    (bbltn (match y (bbltn bbltn) (default (fail bblt))))
    ((bbltc bx x') (match y
                      (bbltn (fail bblt))
                      ((bbltc by y') (bbltc (xor bx by) (bblast_bvxor x' y')))))))

(declare bv_bbl_bvxor (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvxor xb yb ) rb)
                           (bblast_term n (bvxor n x y) rb)))))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVADD
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; return the carry bit after adding x y
;; FIXME: not the most efficient thing in the world
(program bblast_bvadd_carry ((a bblt) (b bblt) (carry formula)) formula
(match a
  ( bbltn (match b (bbltn carry) (default (fail formula))))
  ((bbltc ai a') (match b
  	     	   (bbltn (fail formula))
	 	   ((bbltc bi b') (or (and ai bi) (and (xor ai bi) (bblast_bvadd_carry a' b' carry))))))))

;; ripple carry adder where carry is the initial carry bit
(program bblast_bvadd ((a bblt) (b bblt) (carry formula)) bblt
(match a
  ( bbltn (match b (bbltn bbltn) (default (fail bblt))))
  ((bbltc ai a') (match b
  	     	   (bbltn (fail bblt))
	 	   ((bbltc bi b') (bbltc (xor (xor ai bi) (bblast_bvadd_carry a' b' carry))
				  	 (bblast_bvadd a' b' carry)))))))


(program reverse_help ((x bblt) (acc bblt)) bblt
(match x
       (bbltn acc)
       ((bbltc xi x') (reverse_help x' (bbltc xi acc)))))


(program reverseb ((x bblt)) bblt
	 (reverse_help x bbltn))


; AJR: use this version?
;(program bblast_bvadd_2h ((a bblt) (b bblt) (carry formula)) bblt
;(match a
;  ( bbltn (match b (bbltn bbltn) (default (fail bblt))))
;  ((bbltc ai a') (match b
;       (bbltn (fail bblt))
;	 	   ((bbltc bi b')
;	 	     (let carry' (or (and ai bi) (and (xor ai bi) carry))
;	 	     (bbltc (xor (xor ai bi) carry)
;				  	    (bblast_bvadd_2h a' b' carry'))))))))

;(program bblast_bvadd_2 ((a bblt) (b bblt) (carry formula)) bblt
;(let ar (reverseb a) ;; reverse a and b so that we can build the circuit
;(let br (reverseb b) ;; from the least significant bit up
;(let ret (bblast_bvadd_2h ar br carry)
;  (reverseb ret)))))

(declare bv_bbl_bvadd (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvadd xb yb false) rb)
                           (bblast_term n (bvadd n x y) rb)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVNEG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_zero ((n mpz)) bblt
(mp_ifzero n bbltn
	     (bbltc false (bblast_zero (mp_add n (~1))))))

(program bblast_bvneg ((x bblt) (n mpz)) bblt
  (bblast_bvadd (bblast_bvnot x) (bblast_zero n) true))


(declare bv_bbl_bvneg (! n mpz
                      (! x (term (BitVec n))
		      (! xb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
                      (! c (^ (bblast_bvneg xb n) rb)
                           (bblast_term n (bvneg n x) rb))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVMUL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; shift add multiplier

;; (program concat ((a bblt) (b bblt)) bblt
;;   (match a (bbltn b)
;;   	   ((bbltc ai a') (bbltc ai (concat a' b)))))


(program top_k_bits ((a bblt) (k mpz)) bblt
  (mp_ifzero k bbltn
  	     (match a (bbltn (fail bblt))
	     	      ((bbltc ai a') (bbltc ai (top_k_bits a' (mpz_sub k 1)))))))

(program bottom_k_bits ((a bblt) (k mpz)) bblt
 (reverseb (top_k_bits (reverseb a) k)))

;; assumes the least signigicant bit is at the beginning of the list
(program k_bit ((a bblt) (k mpz)) formula
(mp_ifneg k (fail formula)
(match a (bbltn (fail formula))
         ((bbltc ai a') (mp_ifzero k ai (k_bit a' (mpz_sub k 1)))))))

(program and_with_bit ((a bblt) (bt formula)) bblt
(match a (bbltn bbltn)
         ((bbltc ai a') (bbltc (and bt ai) (and_with_bit a' bt)))))

;; a is going to be the current result
;; carry is going to be false initially
;; b is the and of a and b[k]
;; res is going to be bbltn initially
(program mult_step_k_h ((a bblt) (b bblt) (res bblt) (carry formula) (k mpz)) bblt
(match a
  (bbltn (match b (bbltn res) (default (fail bblt))))
  ((bbltc ai a')
    (match b (bbltn (fail bblt))
             ((bbltc bi b')
	     (mp_ifneg (mpz_sub k 1)
	     	         (let carry_out (or (and ai bi) (and (xor ai bi) carry))
			 (let curr (xor (xor ai bi) carry)
			    (mult_step_k_h a' b' (bbltc curr res) carry_out (mpz_sub k 1))))
			 (mult_step_k_h a' b (bbltc ai res) carry (mpz_sub k 1))
))))))

;; assumes that a, b and res have already been reversed
(program mult_step ((a bblt) (b bblt) (res bblt) (n mpz) (k mpz)) bblt
(let k' (mpz_sub n k )
(let ak (top_k_bits a k')
(let b' (and_with_bit ak (k_bit b k))
 (mp_ifzero (mpz_sub k' 1)
   (mult_step_k_h res b' bbltn false k)
   (let res' (mult_step_k_h res b' bbltn false k)
   (mult_step a b (reverseb res') n (mp_add k 1))))))))


(program bblast_bvmul ((a bblt) (b bblt) (n mpz)) bblt
(let ar (reverseb a) ;; reverse a and b so that we can build the circuit
(let br (reverseb b) ;; from the least significant bit up
(let res (and_with_bit ar (k_bit br 0))
     (mp_ifzero (mpz_sub n 1)     ;; if multiplying 1 bit numbers no need to call mult_step
     		res
		(mult_step ar br res n 1))))))

(declare bv_bbl_bvmul (! n mpz
                      (! x (term (BitVec n))
		      (! y (term (BitVec n))
		      (! xb bblt
		      (! yb bblt
		      (! rb bblt
		      (! xbb (bblast_term n x xb)
		      (! ybb (bblast_term n y yb)
                      (! c (^ (bblast_bvmul xb yb n) rb)
                           (bblast_term n (bvmul n x y) rb)))))))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST EQUALS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; bit blast  x = y
; for x,y of size n, it will return a conjunction (x.0 = y.0 ^ ( ... ^ (x.{n-1} = y.{n-1})))
; f is the accumulator formula that builds the equality in the right order
(program bblast_eq_rec ((x bblt) (y bblt) (f formula)) formula
  (match x
    (bbltn (match y (bbltn f) (default (fail formula))))
    ((bbltc fx x') (match y
                      (bbltn (fail formula))
                      ((bbltc fy y') (bblast_eq_rec x' y' (and (iff fx fy) f)))))
    (default (fail formula))))

(program bblast_eq ((x bblt) (y bblt)) formula
	 (match x
	 	((bbltc bx x') (match y ((bbltc by y') (bblast_eq_rec x' y' (iff bx by)))
			       	      	(default (fail formula))))
		(default (fail formula))))


;; TODO: a temporary bypass for rewrites that we don't support yet. As soon
;; as we do, remove this rule.

(declare bv_bbl_=_false
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_eq bx by) f)
            (th_holds (iff (= (BitVec n) x y) false))))))))))))

(declare bv_bbl_=
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_eq bx by) f)
            (th_holds (iff (= (BitVec n) x y) f))))))))))))

(declare bv_bbl_=_swap
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_eq by bx) f)
            (th_holds (iff (= (BitVec n) x y) f))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVULT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_bvult ((x bblt) (y bblt) (n mpz)) formula
(match x
  ( bbltn (fail formula))
  ((bbltc xi x') (match y
  	     	   (bbltn (fail formula))
	 	   ((bbltc yi y') (mp_ifzero n
		                    (and (not xi) yi)
				    (or (and (iff xi yi) (bblast_bvult x' y' (mp_add n (~1)))) (and (not xi) yi))))))))

(declare bv_bbl_bvult
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_bvult bx by (mp_add n (~1))) f)
            (th_holds (iff (bvult n x y) f))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVSLT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_bvslt ((x bblt) (y bblt) (n mpz)) formula
(match x
  ( bbltn (fail formula))
  ((bbltc xi x') (match y
  	     	   (bbltn (fail formula))
	 	   ((bbltc yi y') (mp_ifzero (mpz_sub n 1)
		   	      	  	     (and xi (not yi))
		   	      		     (or (and (iff xi yi)
					     	      (bblast_bvult x' y' (mpz_sub n 2)))
					     	 (and xi (not yi)))))))))

(declare bv_bbl_bvslt
	 (! n mpz
	 (! x (term (BitVec n))
         (! y (term (BitVec n))
         (! bx bblt
         (! by bblt
         (! f formula
         (! bbx (bblast_term n x bx)
         (! bby (bblast_term n y by)
         (! c (^ (bblast_bvslt bx by n) f)
            (th_holds (iff (bvslt n x y) f))))))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BITBLAST BVCOMP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(program bblast_bvcomp ((x bblt) (y bblt) (n mpz)) bblt
  (match x ((bbltc bx x') (match y ((bbltc by y')
  	   	                      (bbltc (bblast_eq_rec x' y' (iff bx by)) bbltn))
                                   (default (fail bblt))))
           (default (fail bblt))
	   ))

(declare bv_bbl_bvcomp (! n mpz
                       (! x (term (BitVec n))
		       (! y (term (BitVec n))
		       (! xb bblt
		       (! yb bblt
		       (! rb bblt
		       (! xbb (bblast_term n x xb)
		       (! ybb (bblast_term n y yb)
                       (! c (^ (bblast_bvcomp xb yb n) rb)
                              (bblast_term 1 (bvcomp n x y) rb)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;           BITBLASTING CONNECTORS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; bit-blasting connections

(declare intro_assump_t
	 (! f formula
	 (! v var
	 (! C clause
	 (! h (th_holds f)
	 (! a (atom v f)
	 (! u (! unit (holds (clc (pos v) cln))
	      	 (holds C))
	 (holds C))))))))

(declare intro_assump_f
	 (! f formula
	 (! v var
	 (! C clause
	 (! h (th_holds (not f))
	 (! a (atom v f)
	 (! u (! unit (holds (clc (neg v) cln))
	      	 (holds C))
	 (holds C))))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;           REWRITE RULES
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; rewrite rule :
; x + y = y + x
(declare bvadd_symm
	 (! n mpz
	 (! x (term (BitVec n))
	 (! y (term (BitVec n))
	    (th_holds (= (BitVec n) (bvadd _ x y) (bvadd _ y x)))))))

;; (declare bvcrazy_rewrite
;; 	 (! n mpz
;; 	 (! x (term (BitVec n))
;; 	 (! y (term (BitVec n))
;; 	 (! xn bv_poly
;; 	 (! yn bv_poly
;; 	 (! hxn (bv_normalizes x xn)
;; 	 (! hyn (bv_normalizes y yn)
;; 	 (! s (^ (rewrite_scc xn yn) true)
;; 	 (! u (! x (term (BitVec n)) (holds cln))
;; 	     (holds cln)))))))))))

;; 	    (th_holds (= (BitVec n) (bvadd x y) (bvadd y x)))))))



; necessary?
;; (program calc_bvand ((a bv) (b bv)) bv
;;   (match a
;;     (bvn (match b (bvn bvn) (default (fail bv))))
;;     ((bvc ba a') (match b
;;                       ((bvc bb b') (bvc (match ba (b0 b0) (b1 bb)) (calc_bvand a' b')))
;;                       (default (fail bv))))))

;; ; rewrite rule (w constants) :
;; ; a & b = c
;; (declare bvand_const (! c bv
;; 		     (! a bv
;;                      (! b bv
;;                      (! u (^ (calc_bvand a b) c)
;;                         (th_holds (= BitVec (bvand (a_bv a) (a_bv b)) (a_bv c))))))))


;; making constant bit-vectors
(program mk_ones ((n mpz)) bv
	(mp_ifzero n bvn (bvc b1 (mk_ones (mpz_sub n 1)))))

(program mk_zero ((n mpz)) bv
	(mp_ifzero n bvn (bvc b0 (mk_ones (mpz_sub n 1)))))



;; (bvxnor a b) => (bvnot (bvxor a b))
;; (declare bvxnor_elim
;; 	 (! n mpz
;; 	 (! a (term (BitVec n))
;; 	 (! b (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! b' (term (BitVec n))
;; 	 (! rwa (rw_term _ a a')
;; 	 (! rwb (rw_term _ b b')
;; 	 (rw_term n (bvxnor _ a b)
;; 	 	  (bvnot _ (bvxor _ a' b')))))))))))



;; ;; (bvxor a 0) => a
;; (declare bvxor_zero
;; 	 (! n mpz
;; 	 (! zero_bits bv
;; 	 (! sc (^ (mk_zero n)  zero_bits)
;; 	 (! a (term (BitVec n))
;; 	 (! b (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! rwa (rw_term _  a a')
;; 	 (! rwb (rw_term _ b (a_bv _ zero_bits))
;; 	 (rw_term _  (bvxor _ a b)
;; 	 	  a'))))))))))

;; ;; (bvxor a 11) => (bvnot a)
;; (declare bvxor_one
;; 	 (! n mpz
;; 	 (! one_bits bv
;; 	 (! sc (^ (mk_ones n)  one_bits)
;; 	 (! a (term (BitVec n))
;; 	 (! b (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! rwa (rw_term _  a a')
;; 	 (! rwb (rw_term _  b (a_bv _ one_bits))
;; 	 (rw_term _ (bvxor _ a b)
;; 	 	  (bvnot _ a')))))))))))


;; ;; (bvnot (bvnot a)) => a
;; (declare bvnot_idemp
;; 	 (! n mpz
;; 	 (! a (term (BitVec n))
;; 	 (! a' (term (BitVec n))
;; 	 (! rwa (rw_term _  a a')
;; 	 (rw_term _ (bvnot _ (bvnot _ a))
;; 	 	  a'))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Theory of Arrays
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; depends on : th_base.plf

; sorts

(declare Array (! s1 sort (! s2 sort sort)))	; s1 is index, s2 is element

; functions
(declare write (! s1 sort
               (! s2 sort
                 (term (arrow (Array s1 s2)
                       (arrow s1
                       (arrow s2 (Array s1 s2))))))))

(declare read (! s1 sort
              (! s2 sort
              	(term (arrow (Array s1 s2)
               	      (arrow s1 s2))))))

; inference rules

; read( a[i] = b, i ) == b
(declare row1 (! s1 sort
              (! s2 sort
              (! t1 (term (Array s1 s2))
              (! t2 (term s1)
              (! t3 (term s2)
              	(th_holds (= _
		(apply _ _ (apply _ _ (read s1 s2) (apply _ _ (apply _ _ (apply _ _ (write s1 s2) t1) t2) t3)) t2) t3))))))))

; read( a[i] = b, j ) == read( a, j ) if i != j
(declare row (! s1 sort
             (! s2 sort
             (! t2 (term s1)
             (! t3 (term s1)
             (! t1 (term (Array s1 s2))
             (! t4 (term s2)
             (! u (th_holds (not (= _ t2 t3)))
               (th_holds (= _ (apply _ _ (apply _ _ (read s1 s2) (apply _ _ (apply _ _ (apply _ _ (write s1 s2) t1) t2) t4)) t3)
               		      (apply _ _ (apply _ _ (read s1 s2) t1) t3)))))))))))

; i == j if read( a, j ) != read( a[i] = b, j )
(declare negativerow (! s1 sort
                     (! s2 sort
                     (! t2 (term s1)
                     (! t3 (term s1)
                     (! t1 (term (Array s1 s2))
                     (! t4 (term s2)
		     (! u (th_holds (not (= _
                        (apply _ _ (apply _ _ (read s1 s2) (apply _ _ (apply _ _ (apply _ _ (write s1 s2) t1) t2) t4)) t3)
                        (apply _ _ (apply _ _ (read s1 s2) t1) t3))))
                     (th_holds (= _ t2 t3))))))))))

(declare ext (! s1 sort
             (! s2 sort
             (! t1 (term (Array s1 s2))
             (! t2 (term (Array s1 s2))
             (! u1 (! k (term s1)
                   (! u2 (th_holds (or (= _ t1 t2) (not (= _ (apply _ _ (apply _ _ (read s1 s2) t1) k) (apply _ _ (apply _ _ (read s1 s2) t2) k)))))
                     (holds cln)))
               (holds cln)))))))
(declare Int sort)

(define arithpred_Int (! x (term Int)
                      (! y (term Int)
                        formula)))

(declare >_Int arithpred_Int)
(declare >=_Int arithpred_Int)
(declare <_Int  arithpred_Int)
(declare <=_Int arithpred_Int)

(define arithterm_Int (! x (term Int)
		      (! y (term Int)
		        (term Int))))

(declare +_Int arithterm_Int)
(declare -_Int arithterm_Int)
(declare *_Int arithterm_Int)  ; is * ok to use?
(declare /_Int arithterm_Int)  ; is / ok to use?

; a constant term
(declare a_int (! x mpz (term Int)))

; unary negation
(declare u-_Int (! t (term Int) (term Int)))
(declare forall (! s sort
                (! t (term s)
                (! f formula
                  formula))))

;This program recursively checks the instantiation.
;Composite terms (such as "apply _ _ ...") are handled recursively.
;Then, if ti and t are equal, we return true. Otherwise, we first verify that t is the variable for which ti is substitued (ifmarked). if this is the case, ti should be equal to k.

;(program is_inst_t ((ti term) (t term) (k term)) bool
; (match t
;   ((apply s1 s2 t1 t2)
;     (match ti
;       ((apply si1 si2 ti1 ti2) 
;           (match (is_inst_t ti1 t1 k) (tt (is_inst_t ti2 t2 k)) (ff ff)))
;       (default ff)))
;   (default (ifequal ti t tt (ifmarked t (ifequal ti k tt ff) ff)))))
;
;
;(program is_inst_f ((fi formula) (f formula) (k term)) bool
;  (match f
;    ((and f1 f2) (match fi
;    		   ((and fi1 fi2) (match (is_inst_f fi1 f1 k) (tt (is_inst_f fi2 f2 k)) (ff ff)))
;    		   (default ff)))
;    ((or f1 f2) (match fi
;    		   ((or fi1 fi2) (match (is_inst_f fi1 f1 k) (tt (is_inst_f fi2 f2 k)) (ff ff)))
;    		   (default ff)))
;    ((impl f1 f2) (match fi
;    		   ((impl fi1 fi2) (match (is_inst_f fi1 f1 k) (tt (is_inst_f fi2 f2 k)) (ff ff)))
;    		   (default ff)))
;    ((not f1) (match fi
;    		   ((not fi1) (is_inst_f fi1 f1 k))
;    		   (default ff)))
;    ((iff f1 f2) (match fi
;    		   ((iff fi1 fi2) (match (is_inst_f fi1 f1 k) (tt (is_inst_f fi2 f2 k)) (ff ff)))
;    		   (default ff)))
;    ((xor f1 f2) (match fi
;    		   ((xor fi1 fi2) (match (is_inst_f fi1 f1 k) (tt (is_inst_f fi2 f2 k)) (ff ff)))
;    		   (default ff)))
;    ((ifte f1 f2 f3) (match fi
;    		       ((ifte fi1 fi2 fi3) (match (is_inst_f fi1 f1 k)
;    		       			     (tt (match (is_inst_f fi2 f2 k) (tt (is_inst_f fi3 f3 k)) (ff ff)))
;    		       			     (ff ff)))
;    		       (default ff)))
;    ((= s t1 t2) (match fi
;    		   ((= s ti1 ti2) (match (is_inst_t ti1 t1 k) (tt (is_inst_t ti2 t2 k)) (ff ff)))
;    		   (default ff)))
;    ((forall s t1 f1) (match fi
;    		      ((forall s ti1 fi1) (is_inst_f fi1 f1 k))
;    		      (default ff)))
;    (default ff)))
;
;(program is_inst ((fi formula) (f formula) (t term) (k term)) bool
;  (do (markvar t)
;     (let f1 (is_inst_f fi f k)
;        (do (markvar t) f1))))
;
;(declare skolem
;  (! s sort
;  (! t (term s)
;  (! f formula
;  (! p (th_holds (not (forall s t f)))
;  (! u (! k (term s)
;       (! fi formula
;       (! p1 (th_holds (not fi))
;       (! r (^ (is_inst fi f t k) tt)
;         (holds cln)))))
;    (holds cln)))))))
;
;(declare inst
;  (! s sort
;  (! t (term s)
;  (! f formula
;  (! k (term s)
;  (! fi formula
;  (! p (th_holds (forall s t f))
;  (! r (^ (is_inst fi f t k) tt)
;  (! u (! p1 (th_holds fi)
;            (holds cln))
;    (holds cln))))))))))
;; Depends On: th_smt.plf
(declare Real sort)

(define arithpred_Real (! x (term Real)
                       (! y (term Real)
                         formula)))
(declare >_Real arithpred_Real)
(declare >=_Real arithpred_Real)
(declare <_Real  arithpred_Real)
(declare <=_Real arithpred_Real)

(define arithterm_Real (! x (term Real)
                       (! y (term Real)
                         (term Real))))

(declare +_Real arithterm_Real)
(declare -_Real arithterm_Real)
(declare *_Real arithterm_Real)  ; is * ok to use?
(declare /_Real arithterm_Real)  ; is / ok to use?

; a constant term
(declare a_real (! x mpq (term Real)))

(declare >=0_Real (! x (term Real) formula))
(declare =0_Real (! x (term Real) formula))
(declare >0_Real (! x (term Real) formula))
(declare distinct0_Real (! x (term Real) formula))

; unary negation
(declare u-_Real (! t (term Real) (term Real)))

; Is this rational positive?
(program mpq_ispos ((x mpq)) bool
  (mp_ifneg x ff (mp_ifzero x ff tt)))
; Depends on th_real.plf, th_int.plf, smt.plf, sat.plf

; Some axiom arguments are marked "; Omit", because they can be deduced from
; other arguments and should be replaced with a "_" when invoking the axiom.

;; ====================================== ;;
;; Arith Terms, Predicates, & Conversions ;;
;; ====================================== ;;

; Types for arithmetic variables
; Specifically a real
(declare real_var type)
; Specifically an integer
(declare int_var type)

; Functions to map them to terms
(declare term_real_var (! v real_var (term Real)))
(declare term_int_var (! v int_var (term Int)))

; A function to cast an integer term to real.
(declare term_int_to_real (! i (term Int) (term Real)))


; The recursive functions `reify_int_term` and `reify_real_term` work
; together to  reify or "make real" an integer term. That is, to convert it to
; a real term.  More precisely, they take an integer term and return a real
; term in which any integer variables are immediately converted to real terms,
; and all non-leaves in the term are real-sorted.
;
; They explicitly do not work on integer division, because such a conversion
; would not be correct when integer division is involved.

; This function recursively converts an integer term to a real term.
(program reify_int_term ((t (term Int))) (term Real)
  (match t
    ((term_int_var v) (term_int_to_real (term_int_var v)))
    ((a_int i) (a_real (mpz_to_mpq i)))
    ((+_Int x y) (+_Real (reify_int_term x) (reify_int_term y)))
    ((-_Int x y) (-_Real (reify_int_term x) (reify_int_term y)))
    ((u-_Int x) (u-_Real (reify_int_term x)))
    ((*_Int x y) (*_Real (reify_int_term x) (reify_int_term y)))
    ; Reifying integer division is an error, since it changes the value!
    ((/_Int x y) (fail (term Real)))
  ))

; This function recursively converts a real term to a real term.
; It will never change the top-level node in the term (since that node is
; real), but it may change subterms...
(program reify_real_term ((t (term Real))) (term Real)
  (match t
    ((term_real_var v) (term_real_var v))
    ((a_real v) (a_real v))
    ; We've found an integer term -- reify it!
    ((term_int_to_real t') (reify_int_term t'))
    ((+_Real x y) (+_Real (reify_real_term x) (reify_real_term y)))
    ((-_Real x y) (-_Real (reify_real_term x) (reify_real_term y)))
    ((u-_Real x) (u-_Real (reify_real_term x)))
    ((*_Real x y) (*_Real (reify_real_term x) (reify_real_term y)))
    ((/_Real x y) (/_Real (reify_real_term x) (reify_real_term y)))
  ))

; Predicates of the form (term Integer) (comparison) (term Real)
(define arithpred_IntReal (! x (term Int)
                          (! y (term Real)
                          formula)))
(declare >_IntReal arithpred_IntReal)
(declare >=_IntReal arithpred_IntReal)
(declare <_IntReal  arithpred_IntReal)
(declare <=_IntReal arithpred_IntReal)

; From an arith predicate, compute the equivalent real predicate
; All arith predicates are (possibly negated) >='s with a real on the right.
; Technically it's a real literal on the right, but we don't assume that here.
(program reify_arith_pred ((p formula)) formula
  (match p
         ((not p') (not (reify_arith_pred p')))
         ((>=_Real x y) (>=_Real (reify_real_term x) (reify_real_term y)))
         ((>=_Int x y) (>=_Real (reify_int_term x) (reify_int_term y)))
         ((>=_IntReal x y) (>=_Real (reify_int_term x) (reify_real_term y)))
         (default (fail formula))
         ))

; From an arith predicate, prove the equivalent real predicate
(declare pf_reified_arith_pred
  (! p formula
  (! p' formula
    (! pf (th_holds p)
      (! reify_sc (^ (reify_arith_pred p) p')
         (th_holds p'))))))

;; ========================== ;;
;; Int Bound Tightening Rules ;;
;; ========================== ;;

; Returns whether `ceil` is the ceiling of `q`.
(program is_ceil ((q mpq) (ceil mpz)) bool
  (let diff (mp_add (mpz_to_mpq ceil) (mp_neg q))
    (mp_ifneg diff
              ff
              (mp_ifneg (mp_add diff (~ 1/1))
                        tt
                        ff))))

; Returns whether `n` is the greatest integer less than `q`.
(program is_greatest_integer_below ((n mpz) (q mpq)) bool
  (is_ceil q (mp_add n 1)))


; Negates terms of the form:
; (a) k     OR
; (b) x     OR
; (c) k * x
; where k is a constant and x is a variable.
; Otherwise fails.
; This aligns closely with the LFSCArithProof::printLinearMonomialNormalizer
; function.
(program negate_linear_monomial_int_term ((t (term Int))) (term Int)
  (match t
    ((term_int_var v) (*_Int (a_int (~ 1)) (term_int_var v)))
    ((a_int k) (a_int (mp_neg k)))
    ((*_Int x y)
     (match x
            ((a_int k)
             (match y
                    ((term_int_var v) (*_Int (a_int (mp_neg k)) y))
                    (default (fail (term Int)))))
            (default (fail (term Int)))))
    (default (fail (term Int)))
  ))

; This function negates linear interger terms---sums of terms of the form
; recognized by `negate_linear_monomial_int_term`.
(program negate_linear_int_term ((t (term Int))) (term Int)
  (match t
    ((term_int_var v) (negate_linear_monomial_int_term t))
    ((a_int i) (negate_linear_monomial_int_term t))
    ((+_Int x y) (+_Int (negate_linear_int_term x) (negate_linear_int_term y)))
    ((*_Int x y) (negate_linear_monomial_int_term t))
    (default (fail (term Int)))
  ))

; Statement that z is the greatest integer less than z'.
(declare holds_neg_of_greatest_integer_below_int
  (! z mpz
  (! z' mpz
    type)))

; For proving statements of the above form.
(declare check_neg_of_greatest_integer_below_int
  (! z mpz
  (! z' mpz
    (! sc_check (^ (is_greatest_integer_below (mp_neg z) (mpz_to_mpq z')) tt)
       (holds_neg_of_greatest_integer_below_int z z')))))

; Axiom for tightening [Int] < i into -[Int] >= -(i - 1).
; Note that [Int] < i is actually not([Int] >= i)
(declare tighten_not_>=_IntInt
  (! t       (term Int)  ; Omit
  (! neg_t   (term Int)  ; Omit
  (! old_bound     mpz ; Omit
  (! neg_int_bound mpz ; Omit
    (! pf_step (holds_neg_of_greatest_integer_below_int neg_int_bound old_bound)
    ; Note that even when the RHS is an integer, we convert it to real and use >_IntReal
    (! pf_real_bound (th_holds (not (>=_IntReal t (term_int_to_real (a_int old_bound)))))
      (! sc_neg (^ (negate_linear_int_term t) neg_t)
        (th_holds (>=_IntReal neg_t (term_int_to_real (a_int neg_int_bound))))))))))))

;; ======================================== ;;
;; Linear Combinations and Affine functions ;;
;; ======================================== ;;

; Unifying type for both kinds of arithmetic variables
(declare arith_var type)
(declare av_from_int (! v int_var arith_var))
(declare av_from_real (! v real_var arith_var))

; Total order type -- return value for the comparison of two things
(declare ord type)
(declare ord_lt ord)
(declare ord_eq ord)
(declare ord_gt ord)

; Compare two arith vars. Integers come before reals, and otherwise we use the
; LFSC ordering
(program arith_var_cmp ((v1 arith_var) (v2 arith_var)) ord
  (match v1
    ((av_from_int  i1)
      (match v2
        ((av_from_int  i2)
          (ifequal i1 i2
            ord_eq
            (compare i1 i2 ord_lt ord_gt)))
        ((av_from_real r2) ord_lt)))
    ((av_from_real r1)
      (match v2
        ((av_from_int  i2) ord_gt)
        ((av_from_real r2)
          (ifequal r1 r2
            ord_eq
            (compare r1 r2 ord_lt ord_gt)))))))

; Type for linear combinations of variables
; NB: Functions below will assume that the list is always sorted by variable!
(declare lc type)
(declare lc_null lc)
(declare lc_cons (! c mpq (! v arith_var (! rest lc lc))))

; Sum of linear combinations.
(program lc_add ((l1 lc) (l2 lc)) lc
  (match l1
    (lc_null l2)
    ((lc_cons c1 v1 l1')
      (match l2
        (lc_null l1)
        ((lc_cons c2 v2 l2')
          (match (arith_var_cmp v1 v2)
            (ord_lt (lc_cons c1 v1 (lc_add l1' l2)))
            (ord_eq
              (let c (mp_add c1 c2)
                (mp_ifzero c
                  (lc_add l1' l2')
                  (lc_cons c v1 (lc_add l1' l2')))))
            (ord_gt (lc_cons c2 v2 (lc_add l1 l2')))))))))

; Scaling a linear combination
(program lc_mul_c ((l lc) (c mpq)) lc
  (match l
    (lc_null l)
    ((lc_cons c' v' l') (lc_cons (mp_mul c c') v' (lc_mul_c l' c)))))

; Negating a linear combination
(program lc_neg ((l lc)) lc
         (lc_mul_c l (~ 1/1)))

; An affine function of variables (a linear combination + a constant)
(declare aff type)
(declare aff_cons (! c mpq (! l lc aff)))

; Sum of affine functions
(program aff_add ((p1 aff) (p2 aff)) aff
  (match p1
    ((aff_cons c1 l1)
      (match p2
        ((aff_cons c2 l2) (aff_cons (mp_add c1 c2) (lc_add l1 l2)))))))

; Scaling an affine function
(program aff_mul_c ((p aff) (c mpq)) aff
  (match p
    ((aff_cons c' l') (aff_cons (mp_mul c' c) (lc_mul_c l' c)))))

; Negating an affine function
(program aff_neg ((p aff)) aff
  (aff_mul_c p (~ 1/1)))

; Subtracting affine functions
(program aff_sub ((p1 aff) (p2 aff)) aff
  (aff_add p1 (aff_neg p2)))

;; ================================= ;;
;; Proving (Real) terms to be affine ;;
;; ================================= ;;

; truth type for some real term being affine
; * `t` the real term
; * `a` the equivalent affine function
(declare is_aff (! t (term Real) (! a aff type)))

; Constants are affine
(declare is_aff_const
  (! x mpq
    (is_aff (a_real x) (aff_cons x lc_null))))

; Real variables are affine
(declare is_aff_var_real
  (! v real_var
    (is_aff (term_real_var v)
            (aff_cons 0/1 (lc_cons 1/1 (av_from_real v) lc_null)))))

; Int variables are affine
(declare is_aff_var_int
  (! v int_var
    (is_aff (term_int_to_real (term_int_var v))
            (aff_cons 0/1 (lc_cons 1/1 (av_from_int v) lc_null)))))

; affine functions are closed under addition
(declare is_aff_+
  (! x (term Real)      ; Omit
  (! aff_x aff          ; Omit
  (! y (term Real)      ; Omit
  (! aff_y aff          ; Omit
  (! aff_z aff          ; Omit
    (! is_affx (is_aff x aff_x)
    (! is_affy (is_aff y aff_y)
      (! a (^ (aff_add aff_x aff_y) aff_z)
        (is_aff (+_Real x y) aff_z))))))))))

; affine functions are closed under subtraction
(declare is_aff_-
  (! x (term Real)      ; Omit
  (! aff_x aff          ; Omit
  (! y (term Real)      ; Omit
  (! aff_y aff          ; Omit
  (! aff_z aff          ; Omit
    (! is_affx (is_aff x aff_x)
    (! is_affy (is_aff y aff_y)
      (! a (^ (aff_sub aff_x aff_y) aff_z)
        (is_aff (-_Real x y) aff_z))))))))))

; affine functions are closed under left-multiplication by scalars
(declare is_aff_mul_c_L
  (! y (term Real)      ; Omit
  (! aff_y aff          ; Omit
  (! aff_z aff          ; Omit
    (! x mpq
    (! is_affy (is_aff y aff_y)
      (! a (^ (aff_mul_c aff_y x) aff_z)
        (is_aff (*_Real (a_real x) y) aff_z))))))))

; affine functions are closed under right-multiplication by scalars
(declare is_aff_mul_c_R
  (! y (term Real)      ; Omit
  (! aff_y aff          ; Omit
  (! aff_z aff          ; Omit
    (! x mpq
    (! is_affy (is_aff y aff_y)
      (! a (^ (aff_mul_c aff_y x) aff_z)
        (is_aff (*_Real y (a_real x)) aff_z))))))))

;; ========================== ;;
;; Bounds on Affine Functions ;;
;; ========================== ;;

; Bounds that an affine function might satisfy
(declare bound type)
(declare bound_pos bound)           ; > 0
(declare bound_non_neg bound)       ; >= 0

; formulas over affine functions
; the statement that `a` satisfies `b` for all inputs
(declare bounded_aff (! a aff (! b bound formula)))

; Sum of two bounds (the bound satisfied by the sum of two functions satifying
; the input bounds)
(program bound_add ((b bound) (b2 bound)) bound
  (match b
    (bound_pos bound_pos)
    (bound_non_neg b2)))

; The implication of `a1` satisfying `b` and `a2` satisfying `b2`, obtained by
; summing the inequalities.
(program bounded_aff_add_p ((a1 aff) (b bound) (a2 aff) (b2 bound)) formula
  (bounded_aff (aff_add a1 a2) (bound_add b b2)))


; The implication of scaling the inequality of `a1` satisfying `b`.
(program bounded_aff_mul_c_p ((a1 aff) (b bound) (c mpq)) formula
  (match (mpq_ispos c)
    (tt (bounded_aff (aff_mul_c a1 c) b))
    (ff (fail formula))))

; Does an affine function actuall satisfy a bound, for some input?
(program bound_respected ((b bound) (a aff)) bool
  (match a
    ((aff_cons c combo)
      (match combo
        (lc_null
          (match b
            (bound_pos (mpq_ispos c))
            (bound_non_neg (mp_ifneg c ff tt))))
        (default tt)))))

;; =================================== ;;
;; Axioms for bounded affine functions ;;
;; =================================== ;;

; Always true (used as a initial value when summing many bounds together)
(declare bounded_aff_ax_0_>=_0
  (th_holds (bounded_aff (aff_cons 0/1 lc_null) bound_non_neg)))

; Contradiction axiom: an affine function that does not respect its bounds
(declare bounded_aff_contra
  (! a aff      ; Omit
  (! b bound    ; Omit
    (! pf (th_holds (bounded_aff a b))
      (! sc (^ (bound_respected b a) ff)
         (th_holds false))))))

; Rule for summing two affine bounds to get a third
(declare bounded_aff_add
  (! a1 aff             ; Omit
  (! a2 aff             ; Omit
  (! b bound            ; Omit
  (! b2 bound           ; Omit
  (! ba_sum formula     ; Omit
    (! pf_a1 (th_holds (bounded_aff a1 b))
    (! pf_a2 (th_holds (bounded_aff a2 b2))
       (! sc (^ (bounded_aff_add_p a1 b a2 b2) ba_sum)
         (th_holds ba_sum))))))))))

; Rule for scaling an affine bound
(declare bounded_aff_mul_c
  (! a aff          ; Omit
  (! b bound        ; Omit
  (! ba formula     ; Omit
    (! c mpq
    (! pf_a (th_holds (bounded_aff a b))
       (! sc (^ (bounded_aff_mul_c_p a b c) ba)
         (th_holds ba))))))))


; [y >= x] implies that the aff. function y - x is >= 0
(declare aff_>=_from_term
  (! y (term Real)  ; Omit
  (! x (term Real)  ; Omit
  (! p aff          ; Omit
    (! pf_affine (is_aff (-_Real y x) p)
    (! pf_term_bound (th_holds (>=_Real y x))
      (th_holds (bounded_aff p bound_non_neg))))))))

; not [y >= x] implies that the aff. function -(y - x) is > 0
(declare aff_>_from_term
  (! y (term Real)  ; Omit
  (! x (term Real)  ; Omit
  (! p aff          ; Omit
  (! p_n aff        ; Omit
    (! pf_affine (is_aff (-_Real y x) p)
    (! pf_term_bound (th_holds (not (>=_Real y x)))
      (! sc_neg (^ (aff_neg p) p_n)
        (th_holds (bounded_aff p_n bound_pos))))))))))
(check
 ;; Declarations
(% x_37 (term Bool)
(% x_36 (term Bool)
(% x_7 (term Bool)
(% x_30 (term Bool)
(% x_29 (term Bool)
(% x_53 (term Bool)
(% x_6 (term Bool)
(% x_13 (term Bool)
(% x_2 (term Bool)
(% x_12 (term Bool)
(% x_35 (term Bool)
(% x_1 (term Bool)
(% x_28 (term Bool)
(% x_5 (term Bool)
(% x_3 (term Bool)
(% x_15 (term Bool)
(% x_16 (term Bool)
(% x_31 (term Bool)
(% x_17 (term Bool)
(% x_18 (term Bool)
(% x_33 (term Bool)
(% x_19 (term Bool)
(% x_20 (term Bool)
(% x_34 (term Bool)
(% x_32 (term Bool)
(% termITE_1 real_var
(@ term.termITE_1 (term_real_var termITE_1)
(% termITE_2 real_var
(@ term.termITE_2 (term_real_var termITE_2)
(% termITE_8 real_var
(@ term.termITE_8 (term_real_var termITE_8)
(% termITE_13 real_var
(@ term.termITE_13 (term_real_var termITE_13)
(% termITE_17 real_var
(@ term.termITE_17 (term_real_var termITE_17)
(% x_14 real_var
(@ term.x_14 (term_real_var x_14)
(% termITE_25 int_var
(@ term.termITE_25 (term_int_var termITE_25)
(% x_22 real_var
(@ term.x_22 (term_real_var x_22)
(% x_23 real_var
(@ term.x_23 (term_real_var x_23)
(% x_25 real_var
(@ term.x_25 (term_real_var x_25)
(% termITE_26 real_var
(@ term.termITE_26 (term_real_var termITE_26)
(% x_42 real_var
(@ term.x_42 (term_real_var x_42)
(% termITE_21 real_var
(@ term.termITE_21 (term_real_var termITE_21)
(% x_43 real_var
(@ term.x_43 (term_real_var x_43)
(% termITE_7 int_var
(@ term.termITE_7 (term_int_var termITE_7)
(% x_21 real_var
(@ term.x_21 (term_real_var x_21)
(% x_44 real_var
(@ term.x_44 (term_real_var x_44)
(% x_52 real_var
(@ term.x_52 (term_real_var x_52)
(% x_0 real_var
(@ term.x_0 (term_real_var x_0)
(% x_24 real_var
(@ term.x_24 (term_real_var x_24)
(% termITE_12 int_var
(@ term.termITE_12 (term_int_var termITE_12)
(% x_39 real_var
(@ term.x_39 (term_real_var x_39)
(% x_27 real_var
(@ term.x_27 (term_real_var x_27)
(% termITE_3 real_var
(@ term.termITE_3 (term_real_var termITE_3)
(% termITE_19 real_var
(@ term.termITE_19 (term_real_var termITE_19)
(% x_50 real_var
(@ term.x_50 (term_real_var x_50)
(% termITE_23 int_var
(@ term.termITE_23 (term_int_var termITE_23)
(% x_55 real_var
(@ term.x_55 (term_real_var x_55)
(% x_8 real_var
(@ term.x_8 (term_real_var x_8)
(% x_11 real_var
(@ term.x_11 (term_real_var x_11)
(% x_10 real_var
(@ term.x_10 (term_real_var x_10)
(% x_56 real_var
(@ term.x_56 (term_real_var x_56)
(% x_54 real_var
(@ term.x_54 (term_real_var x_54)
(% x_38 real_var
(@ term.x_38 (term_real_var x_38)
(% termITE_31 int_var
(@ term.termITE_31 (term_int_var termITE_31)
(% x_51 real_var
(@ term.x_51 (term_real_var x_51)
(% x_4 real_var
(@ term.x_4 (term_real_var x_4)
(% x_47 real_var
(@ term.x_47 (term_real_var x_47)
(% termITE_15 real_var
(@ term.termITE_15 (term_real_var termITE_15)
(% x_26 real_var
(@ term.x_26 (term_real_var x_26)
(% x_9 real_var
(@ term.x_9 (term_real_var x_9)
(% termITE_10 int_var
(@ term.termITE_10 (term_int_var termITE_10)
(% termITE_5 int_var
(@ term.termITE_5 (term_int_var termITE_5)
(% x_49 real_var
(@ term.x_49 (term_real_var x_49)
(% termITE_20 real_var
(@ term.termITE_20 (term_real_var termITE_20)
(% x_48 real_var
(@ term.x_48 (term_real_var x_48)
(% termITE_14 real_var
(@ term.termITE_14 (term_real_var termITE_14)
(% termITE_29 int_var
(@ term.termITE_29 (term_int_var termITE_29)
(% x_40 real_var
(@ term.x_40 (term_real_var x_40)
(% x_41 real_var
(@ term.x_41 (term_real_var x_41)
(% x_45 real_var
(@ term.x_45 (term_real_var x_45)
(% termITE_30 int_var
(@ term.termITE_30 (term_int_var termITE_30)
(% x_46 real_var
(@ term.x_46 (term_real_var x_46)
(% A1 (th_holds true)
(% A0 (th_holds (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (<=_Real term.x_4 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) )) (>=_Real term.x_4 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (<=_Real term.x_0 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_0 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>_Real term.x_8 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_8 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_9 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_10 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_11 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_14 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (or (or (or (= Real term.x_21 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (= Real term.x_21 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (= Real term.x_21 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ))) (= Real term.x_21 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) )))) (not (<_Real term.x_21 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )))) (<=_Real term.x_21 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (or (or (or (= Real term.x_22 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (= Real term.x_22 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (= Real term.x_22 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ))) (= Real term.x_22 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) )))) (not (<_Real term.x_22 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )))) (<=_Real term.x_22 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (or (or (or (= Real term.x_23 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (= Real term.x_23 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (= Real term.x_23 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ))) (= Real term.x_23 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) )))) (not (<_Real term.x_23 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )))) (<=_Real term.x_23 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (or (or (or (= Real term.x_24 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (= Real term.x_24 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (= Real term.x_24 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ))) (= Real term.x_24 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) )))) (not (<_Real term.x_24 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )))) (<=_Real term.x_24 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (or (or (or (= Real term.x_25 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (= Real term.x_25 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (= Real term.x_25 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ))) (= Real term.x_25 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) )))) (not (<_Real term.x_25 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )))) (<=_Real term.x_25 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (or (or (or (= Real term.x_26 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (= Real term.x_26 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (= Real term.x_26 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ))) (= Real term.x_26 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) )))) (not (<_Real term.x_26 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )))) (<=_Real term.x_26 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_27 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_38 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_39 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_42 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_43 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_44 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_47 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_50 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_51 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (not (<=_Real term.x_52 (*_Real term.x_8 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))))) (>=_Real term.x_52 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_54 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_55 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (>=_Real term.x_56 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (or (not (= Real term.x_0 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (and (and (not (p_app x_1)) (not (p_app x_2))) (not (p_app x_3))))) (or (not (= Real term.x_4 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (and (and (not (p_app x_5)) (not (p_app x_6))) (not (p_app x_7))))) (or (not (= Real term.x_0 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (and (and (not (p_app x_1)) (not (p_app x_2))) (not (p_app x_3))))) (= Real term.x_40 (/_Real (ite _ (p_app x_1) (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ) (term_int_to_real (a_int 1)) ))) (= Real term.x_41 (/_Real (ite _ (p_app x_18) (term_int_to_real (a_int 1))  (term_int_to_real (a_int 2)) ) (term_int_to_real (a_int 1)) ))) (= Real term.x_45 (/_Real (ite _ (and (not (<=_Real term.x_39 term.x_9)) (<=_Real term.x_39 term.x_11)) (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ) (term_int_to_real (a_int 1)) ))) (= Real term.x_46 (/_Real (ite _ (and (not (<=_Real term.x_39 term.x_9)) (<=_Real term.x_39 term.x_11)) (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) ) (term_int_to_real (a_int 1)) ))) (= Real term.x_48 (+_Real (ite _ (and (not (<=_Real term.x_47 term.x_9)) (<=_Real term.x_47 term.x_11)) (ite _ (and (not (<=_Real term.x_44 term.x_9)) (<=_Real term.x_44 term.x_11)) (ite _ (and (not (<=_Real term.x_39 term.x_9)) (<=_Real term.x_39 term.x_11)) (term_int_to_real (a_int 3))  (term_int_to_real (a_int 2)) ) term.x_45) (ite _ (and (not (<=_Real term.x_44 term.x_9)) (<=_Real term.x_44 term.x_11)) term.x_45 (ite _ (and (not (<=_Real term.x_39 term.x_9)) (<=_Real term.x_39 term.x_11)) (term_int_to_real (a_int 1))  (term_int_to_real (a_int 0)) ))) term.x_22))) (= Real term.x_49 (+_Real (ite _ (and (not (<=_Real term.x_47 term.x_9)) (<=_Real term.x_47 term.x_11)) (ite _ (and (not (<=_Real term.x_44 term.x_9)) (<=_Real term.x_44 term.x_11)) (ite _ (and (not (<=_Real term.x_39 term.x_9)) (<=_Real term.x_39 term.x_11)) (term_int_to_real (a_int 3))  (term_int_to_real (a_int 2)) ) term.x_46) (ite _ (and (not (<=_Real term.x_44 term.x_9)) (<=_Real term.x_44 term.x_11)) term.x_46 (ite _ (and (not (<=_Real term.x_39 term.x_9)) (<=_Real term.x_39 term.x_11)) (term_int_to_real (a_int 1))  (term_int_to_real (a_int 0)) ))) term.x_22))) (or (or (and (and (and (and (and (and (or (and (and (and (and (and (and (and (and (and (and (= Real term.x_4 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (<_Real term.x_10 term.x_14)) (= Real term.x_11 term.x_10)) (= Real term.x_23 (ite _ (not (p_app x_18)) (ite _ (and (and (not (<=_Real term.x_42 term.x_9)) (<=_Real term.x_42 term.x_11)) (<_Real term.x_24 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (+_Real term.x_24 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) term.x_24) term.x_24))) (= Real term.x_25 (ite _ (not (p_app x_20)) (ite _ (and (and (not (<=_Real term.x_43 term.x_9)) (<=_Real term.x_43 term.x_11)) (<_Real term.x_26 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (+_Real term.x_26 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) term.x_26) term.x_26))) (= Real term.x_21 (ite _ (not (p_app x_16)) (ite _ (not (<_Real term.x_48 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (term_int_to_real (a_int 3))  term.x_48) term.x_22))) (iff (p_app x_17) (or (p_app x_18) (= Real term.x_23 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))))) (iff (p_app x_19) (or (p_app x_20) (= Real term.x_25 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))))) (iff (p_app x_15) (or (p_app x_16) (= Real term.x_21 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))))) (iff (p_app x_28) (p_app x_29) )) (= Real term.x_27 term.x_14)) (and (and (and (and (and (and (and (and (and (and (= Real term.x_4 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (not (<_Real term.x_10 term.x_14))) (p_app x_28)) (= Real term.x_11 term.x_14)) (= Real term.x_23 (ite _ (not (p_app x_18)) (ite _ (and (and (not (<=_Real term.x_42 term.x_9)) (<=_Real term.x_42 term.x_11)) (<_Real term.x_24 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (+_Real term.x_24 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) term.x_24) term.x_24))) (= Real term.x_25 (ite _ (not (p_app x_20)) (ite _ (and (and (not (<=_Real term.x_43 term.x_9)) (<=_Real term.x_43 term.x_11)) (<_Real term.x_26 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (+_Real term.x_26 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) term.x_26) term.x_26))) (= Real term.x_21 (ite _ (not (p_app x_16)) (ite _ (not (<_Real term.x_49 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (term_int_to_real (a_int 3))  term.x_49) term.x_22))) (iff (p_app x_17) (or (or (p_app x_18) (= Real term.x_23 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (= Real term.x_23 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))))) (iff (p_app x_19) (or (or (p_app x_20) (= Real term.x_25 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (= Real term.x_25 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))))) (iff (p_app x_15) (or (or (p_app x_16) (= Real term.x_21 (/_Real (term_int_to_real (a_int 3))  (term_int_to_real (a_int 1)) ))) (= Real term.x_21 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))))) (= Real term.x_27 term.x_14))) (iff (p_app x_30) (p_app x_31) )) (and (iff (p_app x_32) (p_app x_33) ) (iff (p_app x_34) (p_app x_35) ))) (iff (p_app x_36) (p_app x_37) )) (iff (p_app x_7) (p_app x_3) )) (and (iff (p_app x_5) (p_app x_1) ) (iff (p_app x_6) (p_app x_2) ))) (iff (p_app x_12) (p_app x_13) )) (and (and (and (and (and (and (and (or (and (and (and (and (and (and (and (and (and (and (and (= Real term.x_4 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) (or (or (and (and (and (not (<=_Real term.x_42 term.x_9)) (not (p_app x_18))) (not (p_app x_33))) (<=_Real term.x_42 (+_Real term.x_8 term.x_9))) (and (and (and (not (<=_Real term.x_43 term.x_9)) (not (p_app x_20))) (not (p_app x_35))) (<=_Real term.x_43 (+_Real term.x_8 term.x_9)))) (and (and (not (p_app x_16)) (not (p_app x_31))) (<=_Real term.x_39 (+_Real term.x_8 term.x_9))))) (not (p_app x_36))) (or (or (or (or (<=_Real term.x_42 term.x_9) (not (<=_Real term.x_42 (+_Real term.x_8 term.x_9)))) (p_app x_33)) (p_app x_18)) (not (<_Real term.x_11 term.x_42)))) (or (or (or (or (<=_Real term.x_43 term.x_9) (not (<=_Real term.x_43 (+_Real term.x_8 term.x_9)))) (p_app x_35)) (p_app x_20)) (not (<_Real term.x_11 term.x_43)))) (or (or (or (not (<=_Real term.x_39 (+_Real term.x_8 term.x_9))) (p_app x_31)) (p_app x_16)) (not (<_Real term.x_11 term.x_39)))) (or (or (or (and (and (and (and (not (p_app x_33)) (not (p_app x_18))) (<=_Real term.x_42 (+_Real term.x_8 term.x_9))) (<_Real term.x_42 term.x_10)) (= Real term.x_11 term.x_42)) (and (and (and (and (not (p_app x_35)) (not (p_app x_20))) (<=_Real term.x_43 (+_Real term.x_8 term.x_9))) (<_Real term.x_43 term.x_10)) (= Real term.x_11 term.x_43))) (and (and (and (and (not (p_app x_31)) (not (p_app x_16))) (<=_Real term.x_39 (+_Real term.x_8 term.x_9))) (<_Real term.x_39 term.x_10)) (= Real term.x_11 term.x_39))) (and (<_Real term.x_10 (+_Real term.x_9 term.x_8)) (= Real term.x_11 term.x_10)))) (iff (p_app x_32) (or (p_app x_33) (and (not (<=_Real term.x_42 term.x_9)) (<=_Real term.x_42 term.x_11))))) (iff (p_app x_34) (or (p_app x_35) (and (not (<=_Real term.x_43 term.x_9)) (<=_Real term.x_43 term.x_11))))) (iff (p_app x_30) (or (p_app x_31) (<=_Real term.x_39 term.x_11)))) (and (iff (p_app x_17) (or (p_app x_18) (and (and (not (<=_Real term.x_42 term.x_9)) (<=_Real term.x_42 term.x_11)) (p_app x_33)))) (iff (p_app x_19) (or (p_app x_20) (and (and (not (<=_Real term.x_43 term.x_9)) (<=_Real term.x_43 term.x_11)) (p_app x_35)))))) (iff (p_app x_15) (or (p_app x_16) (and (<=_Real term.x_39 term.x_11) (p_app x_31))))) (and (and (and (and (and (and (and (and (and (= Real term.x_4 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) (or (or (or (<=_Real term.x_42 term.x_9) (p_app x_33)) (p_app x_18)) (not (<=_Real term.x_42 (+_Real term.x_8 term.x_9))))) (or (or (or (<=_Real term.x_43 term.x_9) (p_app x_35)) (p_app x_20)) (not (<=_Real term.x_43 (+_Real term.x_8 term.x_9))))) (or (or (p_app x_31) (p_app x_16)) (not (<=_Real term.x_39 (+_Real term.x_8 term.x_9))))) (p_app x_36)) (= Real term.x_11 (+_Real term.x_9 term.x_8))) (and (iff (p_app x_17) (or (p_app x_18) (and (and (not (<=_Real term.x_42 term.x_9)) (<=_Real term.x_42 term.x_11)) (p_app x_33)))) (iff (p_app x_19) (or (p_app x_20) (and (and (not (<=_Real term.x_43 term.x_9)) (<=_Real term.x_43 term.x_11)) (p_app x_35)))))) (iff (p_app x_15) (or (p_app x_16) (and (<=_Real term.x_39 term.x_11) (p_app x_31))))) (iff (p_app x_30) (p_app x_31) )) (and (iff (p_app x_32) (p_app x_33) ) (iff (p_app x_34) (p_app x_35) )))) (= Real term.x_21 term.x_22)) (and (= Real term.x_23 term.x_24) (= Real term.x_25 term.x_26))) (= Real term.x_27 term.x_14)) (iff (p_app x_28) (p_app x_29) )) (iff (p_app x_7) (p_app x_3) )) (and (iff (p_app x_5) (p_app x_1) ) (iff (p_app x_6) (p_app x_2) ))) (iff (p_app x_12) (p_app x_13) ))) (and (and (and (and (and (and (and (or (and (and (and (and (and (and (and (and (and (and (and (= Real term.x_4 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) )) (<=_Real (ite _ (p_app x_3) (ite _ (p_app x_2) (ite _ (p_app x_1) (term_int_to_real (a_int 3))  (term_int_to_real (a_int 2)) ) term.x_40) (ite _ (p_app x_2) term.x_40 (ite _ (p_app x_1) (term_int_to_real (a_int 1))  (term_int_to_real (a_int 0)) ))) (*_Real (*_Real (ite _ (p_app x_16) (ite _ (p_app x_20) (ite _ (p_app x_18) (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ) term.x_41) (ite _ (p_app x_20) term.x_41 (ite _ (p_app x_18) (term_int_to_real (a_int 2))  (term_int_to_real (a_int 3)) ))) (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 2)) )))) (not (p_app x_12))) (or (or (or (<=_Real term.x_42 term.x_9) (p_app x_1)) (p_app x_18)) (<=_Real term.x_11 term.x_42))) (or (or (or (<=_Real term.x_43 term.x_9) (p_app x_2)) (p_app x_20)) (<=_Real term.x_11 term.x_43))) (or (or (p_app x_3) (p_app x_16)) (<=_Real term.x_11 term.x_39))) (or (or (or (and (and (and (and (not (p_app x_1)) (not (p_app x_18))) (<_Real term.x_9 term.x_42)) (<_Real term.x_42 term.x_10)) (= Real term.x_11 term.x_42)) (and (and (and (and (not (p_app x_2)) (not (p_app x_20))) (<_Real term.x_9 term.x_43)) (<_Real term.x_43 term.x_10)) (= Real term.x_11 term.x_43))) (and (and (and (not (p_app x_3)) (not (p_app x_16))) (<_Real term.x_39 term.x_10)) (= Real term.x_11 term.x_39))) (= Real term.x_11 term.x_10))) (iff (p_app x_5) (or (p_app x_1) (= Real term.x_42 term.x_11)))) (iff (p_app x_6) (or (p_app x_2) (= Real term.x_43 term.x_11)))) (iff (p_app x_7) (or (p_app x_3) (= Real term.x_39 term.x_11)))) (iff (p_app x_15) (p_app x_16) )) (and (iff (p_app x_17) (p_app x_18) ) (iff (p_app x_19) (p_app x_20) ))) (and (and (and (and (and (and (and (= Real term.x_4 (/_Real (term_int_to_real (a_int 2))  (term_int_to_real (a_int 1)) )) (not (<=_Real (ite _ (p_app x_3) (ite _ (p_app x_2) (ite _ (p_app x_1) (term_int_to_real (a_int 3))  (term_int_to_real (a_int 2)) ) term.x_40) (ite _ (p_app x_2) term.x_40 (ite _ (p_app x_1) (term_int_to_real (a_int 1))  (term_int_to_real (a_int 0)) ))) (*_Real (*_Real (ite _ (p_app x_16) (ite _ (p_app x_20) (ite _ (p_app x_18) (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ) term.x_41) (ite _ (p_app x_20) term.x_41 (ite _ (p_app x_18) (term_int_to_real (a_int 2))  (term_int_to_real (a_int 3)) ))) (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 2)) ))))) (p_app x_12)) (iff (p_app x_15) (p_app x_16) )) (and (iff (p_app x_17) (p_app x_18) ) (iff (p_app x_19) (p_app x_20) ))) (= Real term.x_11 term.x_9)) (iff (p_app x_7) (p_app x_3) )) (and (iff (p_app x_5) (p_app x_1) ) (iff (p_app x_6) (p_app x_2) )))) (= Real term.x_21 term.x_22)) (and (= Real term.x_23 term.x_24) (= Real term.x_25 term.x_26))) (= Real term.x_27 term.x_14)) (iff (p_app x_28) (p_app x_29) )) (iff (p_app x_30) (p_app x_31) )) (and (iff (p_app x_32) (p_app x_33) ) (iff (p_app x_34) (p_app x_35) ))) (iff (p_app x_36) (p_app x_37) )))) (or (or (and (= Real term.x_0 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) )) (= Real term.x_4 (ite _ (not (p_app x_29)) term.x_0 (term_int_to_real (a_int 1)) ))) (and (= Real term.x_0 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )) (= Real term.x_4 (ite _ (not (p_app x_37)) term.x_0 (term_int_to_real (a_int 2)) )))) (and (and (not (= Real term.x_0 (/_Real (term_int_to_real (a_int 0))  (term_int_to_real (a_int 1)) ))) (not (= Real term.x_0 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) )))) (= Real term.x_4 term.x_0)))) (or (and (and (<=_Real term.x_10 term.x_11) (not (<=_Real term.x_38 term.x_50))) (not (<=_Real term.x_50 (-_Real term.x_38 term.x_8)))) (and (not (<=_Real term.x_10 term.x_11)) (= Real term.x_50 term.x_42)))) (or (and (and (<=_Real term.x_10 term.x_11) (not (<=_Real term.x_38 term.x_51))) (not (<=_Real term.x_51 (-_Real term.x_38 term.x_8)))) (and (not (<=_Real term.x_10 term.x_11)) (= Real term.x_51 term.x_43)))) (or (and (and (<=_Real term.x_10 term.x_11) (= Real term.x_38 (+_Real term.x_10 term.x_52))) (p_app x_53)) (and (and (not (<=_Real term.x_10 term.x_11)) (not (p_app x_53))) (= Real term.x_38 term.x_10)))) (or (and (and (and (and (<=_Real term.x_39 term.x_11) (not (<=_Real term.x_54 term.x_11))) (not (<=_Real term.x_55 term.x_11))) (<_Real term.x_54 term.x_55)) (<_Real term.x_55 term.x_56)) (and (and (and (not (<=_Real term.x_39 term.x_11)) (= Real term.x_54 term.x_39)) (= Real term.x_55 term.x_44)) (= Real term.x_56 term.x_47)))) (= Real term.x_4 (/_Real (term_int_to_real (a_int 1))  (term_int_to_real (a_int 1)) ))) (or (or (p_app x_5) (p_app x_6)) (p_app x_7))))
(: (holds cln)

 ;; Printing deferred declarations 


;; BV const letification



 ;; Printing the global let map
(@ let1 x_1
(@ let2 x_2
(@ let3 x_3
(@ let4 x_5
(@ let5 x_6
(@ let6 x_7
(@ let7 x_53
(@ let8 (iff (p_app let6) (p_app let3) )
(@ let9 (iff (p_app let4) (p_app let1) )
(@ let10 (iff (p_app let5) (p_app let2) )
(@ let11 term.x_55
(@ let12 (a_int (~ 1) )
(@ let13 term.x_56
(@ let14 (*_Real (term_int_to_real (a_int (~ 1)) ) let13)
(@ let15 (+_Real let11 let14)
(@ let16 (a_int 0) 
(@ let17 (>=_Real let15 (term_int_to_real (a_int 0)) )
(@ let18 term.x_54
(@ let19 (*_Real (term_int_to_real (a_int (~ 1)) ) let11)
(@ let20 (+_Real let18 let19)
(@ let21 (>=_Real let20 (term_int_to_real (a_int 0)) )
(@ let22 term.x_11
(@ let23 (+_Real let22 let19)
(@ let24 (>=_Real let23 (term_int_to_real (a_int 0)) )
(@ let25 term.x_39
(@ let26 (*_Real (term_int_to_real (a_int (~ 1)) ) let25)
(@ let27 (+_Real let22 let26)
(@ let28 (>=_Real let27 (term_int_to_real (a_int 0)) )
(@ let29 (*_Real (term_int_to_real (a_int (~ 1)) ) let18)
(@ let30 (+_Real let22 let29)
(@ let31 (>=_Real let30 (term_int_to_real (a_int 0)) )
(@ let32 term.x_10
(@ let33 (*_Real (term_int_to_real (a_int (~ 1)) ) let32)
(@ let34 (+_Real let33 let22)
(@ let35 (>=_Real let34 (term_int_to_real (a_int 0)) )
(@ let36 term.x_8
(@ let37 (*_Real (term_int_to_real (a_int (~ 1)) ) let36)
(@ let38 term.x_38
(@ let39 term.x_51
(@ let40 (*_Real (term_int_to_real (a_int (~ 1)) ) let39)
(@ let41 (+_Real let37 (+_Real let38 let40))
(@ let42 (>=_Real let41 (term_int_to_real (a_int 0)) )
(@ let43 (*_Real (term_int_to_real (a_int (~ 1)) ) let38)
(@ let44 (+_Real let43 let39)
(@ let45 (>=_Real let44 (term_int_to_real (a_int 0)) )
(@ let46 term.x_50
(@ let47 (*_Real (term_int_to_real (a_int (~ 1)) ) let46)
(@ let48 (+_Real let37 (+_Real let38 let47))
(@ let49 (>=_Real let48 (term_int_to_real (a_int 0)) )
(@ let50 (+_Real let43 let46)
(@ let51 (>=_Real let50 (term_int_to_real (a_int 0)) )
(@ let52 term.x_26
(@ let53 (a_int 3) 
(@ let54 (>=_Real let52 (term_int_to_real (a_int 3)) )
(@ let55 term.x_24
(@ let56 (>=_Real let55 (term_int_to_real (a_int 3)) )
(@ let57 (not (p_app let3))
(@ let58 (not (p_app let1))
(@ let59 (not (p_app let2))
(@ let60 (and let58 let59)
(@ let61 (and let57 let60)
(@ let62 (>=_Real let13 (term_int_to_real (a_int 0)) )
(@ let63 (>=_Real let11 (term_int_to_real (a_int 0)) )
(@ let64 (>=_Real let18 (term_int_to_real (a_int 0)) )
(@ let65 term.x_52
(@ let66 (>=_Real let65 (term_int_to_real (a_int 0)) )
(@ let67 (a_real (~ 1/3) )
(@ let68 (*_Real let67 let65)
(@ let69 (+_Real let36 let68)
(@ let70 (>=_Real let69 (term_int_to_real (a_int 0)) )
(@ let71 (>=_Real let39 (term_int_to_real (a_int 0)) )
(@ let72 (>=_Real let46 (term_int_to_real (a_int 0)) )
(@ let73 term.x_47
(@ let74 (>=_Real let73 (term_int_to_real (a_int 0)) )
(@ let75 term.x_44
(@ let76 (>=_Real let75 (term_int_to_real (a_int 0)) )
(@ let77 term.x_43
(@ let78 (>=_Real let77 (term_int_to_real (a_int 0)) )
(@ let79 term.x_42
(@ let80 (>=_Real let79 (term_int_to_real (a_int 0)) )
(@ let81 (>=_Real let25 (term_int_to_real (a_int 0)) )
(@ let82 (>=_Real let38 (term_int_to_real (a_int 0)) )
(@ let83 term.x_27
(@ let84 (>=_Real let83 (term_int_to_real (a_int 0)) )
(@ let85 (*_Real (term_int_to_real (a_int (~ 1)) ) let52)
(@ let86 (a_int (~ 3) )
(@ let87 (>=_Real let85 (term_int_to_real (a_int (~ 3)) ))
(@ let88 (>=_Real let52 (term_int_to_real (a_int 0)) )
(@ let89 term.x_25
(@ let90 (*_Real (term_int_to_real (a_int (~ 1)) ) let89)
(@ let91 (>=_Real let90 (term_int_to_real (a_int (~ 3)) ))
(@ let92 (>=_Real let89 (term_int_to_real (a_int 0)) )
(@ let93 (*_Real (term_int_to_real (a_int (~ 1)) ) let55)
(@ let94 (>=_Real let93 (term_int_to_real (a_int (~ 3)) ))
(@ let95 (>=_Real let55 (term_int_to_real (a_int 0)) )
(@ let96 term.x_23
(@ let97 (*_Real (term_int_to_real (a_int (~ 1)) ) let96)
(@ let98 (>=_Real let97 (term_int_to_real (a_int (~ 3)) ))
(@ let99 (>=_Real let96 (term_int_to_real (a_int 0)) )
(@ let100 term.x_22
(@ let101 (*_Real (term_int_to_real (a_int (~ 1)) ) let100)
(@ let102 (>=_Real let101 (term_int_to_real (a_int (~ 3)) ))
(@ let103 (>=_Real let100 (term_int_to_real (a_int 0)) )
(@ let104 term.x_21
(@ let105 (*_Real (term_int_to_real (a_int (~ 1)) ) let104)
(@ let106 (>=_Real let105 (term_int_to_real (a_int (~ 3)) ))
(@ let107 (>=_Real let104 (term_int_to_real (a_int 0)) )
(@ let108 term.x_14
(@ let109 (>=_Real let108 (term_int_to_real (a_int 0)) )
(@ let110 (>=_Real let22 (term_int_to_real (a_int 0)) )
(@ let111 (>=_Real let32 (term_int_to_real (a_int 0)) )
(@ let112 term.x_9
(@ let113 (>=_Real let112 (term_int_to_real (a_int 0)) )
(@ let114 (>=_Real let36 (term_int_to_real (a_int 0)) )
(@ let115 (>=_Real let37 (term_int_to_real (a_int 0)) )
(@ let116 term.x_0
(@ let117 (>=_Real let116 (term_int_to_real (a_int 0)) )
(@ let118 (*_Real (term_int_to_real (a_int (~ 1)) ) let116)
(@ let119 (a_int (~ 2) )
(@ let120 (>=_Real let118 (term_int_to_real (a_int (~ 2)) ))
(@ let121 term.x_4
(@ let122 (*_Real (term_int_to_real (a_int (~ 1)) ) let121)
(@ let123 (>=_Real let122 (term_int_to_real (a_int (~ 2)) ))
(@ let124 (>=_Real let121 (term_int_to_real (a_int 0)) )
(@ let125 term.termITE_31
(@ let126 (a_int 1) 
(@ let127 (>=_IntReal let125 (term_int_to_real (a_int 1)) )
(@ let128 term.termITE_30
(@ let129 (>=_IntReal let128 (term_int_to_real (a_int 1)) )
(@ let130 term.termITE_29
(@ let131 (>=_IntReal let130 (term_int_to_real (a_int 1)) )
(@ let132 term.termITE_25
(@ let133 (>=_IntReal let132 (term_int_to_real (a_int 0)) )
(@ let134 term.termITE_23
(@ let135 (a_int 2) 
(@ let136 (>=_IntReal let134 (term_int_to_real (a_int 2)) )
(@ let137 term.termITE_12
(@ let138 (>=_IntReal let137 (term_int_to_real (a_int 2)) )
(@ let139 term.termITE_10
(@ let140 (>=_IntReal let139 (term_int_to_real (a_int 0)) )
(@ let141 term.termITE_7
(@ let142 (>=_IntReal let141 (term_int_to_real (a_int 0)) )
(@ let143 term.termITE_5
(@ let144 (>=_IntReal let143 (term_int_to_real (a_int 2)) )
(@ let145 (>=_IntReal let125 (term_int_to_real (a_int 3)) )
(@ let146 (>=_IntReal let128 (term_int_to_real (a_int 3)) )
(@ let147 (>=_IntReal let130 (term_int_to_real (a_int 3)) )
(@ let148 (>=_IntReal let132 (term_int_to_real (a_int 2)) )
(@ let149 (a_int 4) 
(@ let150 (>=_IntReal let134 (term_int_to_real (a_int 4)) )
(@ let151 term.x_49
(@ let152 term.termITE_20
(@ let153 (*_Real (term_int_to_real (a_int (~ 1)) ) let152)
(@ let154 (+_Real let151 let153)
(@ let155 (>=_Real let154 (term_int_to_real (a_int 0)) )
(@ let156 (>=_Real let153 (term_int_to_real (a_int (~ 3)) ))
(@ let157 term.x_48
(@ let158 term.termITE_14
(@ let159 (*_Real (term_int_to_real (a_int (~ 1)) ) let158)
(@ let160 (+_Real let157 let159)
(@ let161 (>=_Real let160 (term_int_to_real (a_int 0)) )
(@ let162 (>=_Real let159 (term_int_to_real (a_int (~ 3)) ))
(@ let163 (>=_IntReal let137 (term_int_to_real (a_int 4)) )
(@ let164 (>=_IntReal let139 (term_int_to_real (a_int 2)) )
(@ let165 (>=_IntReal let141 (term_int_to_real (a_int 2)) )
(@ let166 (>=_IntReal let143 (term_int_to_real (a_int 4)) )
(@ let167 (>=_Real let104 (term_int_to_real (a_int 1)) )
(@ let168 (>=_Real let105 (term_int_to_real (a_int (~ 1)) ))
(@ let169 (>=_Real let105 (term_int_to_real (a_int 0)) )
(@ let170 (>=_Real let104 (term_int_to_real (a_int 2)) )
(@ let171 (>=_Real let105 (term_int_to_real (a_int (~ 2)) ))
(@ let172 (>=_Real let104 (term_int_to_real (a_int 3)) )
(@ let173 (>=_Real let100 (term_int_to_real (a_int 1)) )
(@ let174 (>=_Real let101 (term_int_to_real (a_int (~ 1)) ))
(@ let175 (>=_Real let101 (term_int_to_real (a_int 0)) )
(@ let176 (>=_Real let100 (term_int_to_real (a_int 2)) )
(@ let177 (>=_Real let101 (term_int_to_real (a_int (~ 2)) ))
(@ let178 (>=_Real let100 (term_int_to_real (a_int 3)) )
(@ let179 (>=_Real let96 (term_int_to_real (a_int 1)) )
(@ let180 (>=_Real let97 (term_int_to_real (a_int (~ 1)) ))
(@ let181 (>=_Real let97 (term_int_to_real (a_int 0)) )
(@ let182 (>=_Real let96 (term_int_to_real (a_int 2)) )
(@ let183 (>=_Real let97 (term_int_to_real (a_int (~ 2)) ))
(@ let184 (>=_Real let96 (term_int_to_real (a_int 3)) )
(@ let185 (>=_Real let55 (term_int_to_real (a_int 1)) )
(@ let186 (>=_Real let93 (term_int_to_real (a_int (~ 1)) ))
(@ let187 (>=_Real let93 (term_int_to_real (a_int 0)) )
(@ let188 (>=_Real let55 (term_int_to_real (a_int 2)) )
(@ let189 (>=_Real let93 (term_int_to_real (a_int (~ 2)) ))
(@ let190 (>=_Real let89 (term_int_to_real (a_int 1)) )
(@ let191 (>=_Real let90 (term_int_to_real (a_int (~ 1)) ))
(@ let192 (>=_Real let90 (term_int_to_real (a_int 0)) )
(@ let193 (>=_Real let89 (term_int_to_real (a_int 2)) )
(@ let194 (>=_Real let90 (term_int_to_real (a_int (~ 2)) ))
(@ let195 (>=_Real let89 (term_int_to_real (a_int 3)) )
(@ let196 (>=_Real let52 (term_int_to_real (a_int 1)) )
(@ let197 (>=_Real let85 (term_int_to_real (a_int (~ 1)) ))
(@ let198 (>=_Real let85 (term_int_to_real (a_int 0)) )
(@ let199 (>=_Real let52 (term_int_to_real (a_int 2)) )
(@ let200 (>=_Real let85 (term_int_to_real (a_int (~ 2)) ))
(@ let201 (>=_Real let116 (term_int_to_real (a_int 1)) )
(@ let202 (>=_Real let118 (term_int_to_real (a_int (~ 1)) ))
(@ let203 (and let202 let201)
(@ let204 (>=_Real let122 (term_int_to_real (a_int 0)) )
(@ let205 (>=_Real let118 (term_int_to_real (a_int 0)) )
(@ let206 (and let205 let117)
(@ let207 term.x_40
(@ let208 (*_Real (term_int_to_real (a_int (~ 1)) ) let207)
(@ let209 (+_Real let208 (term_int_to_real term.termITE_31))
(@ let210 (>=_Real let209 (term_int_to_real (a_int 0)) )
(@ let211 (*_Int let12 let125)
(@ let212 (+_Real let207 (term_int_to_real (*_Int let12 let125)))
(@ let213 (>=_Real let212 (term_int_to_real (a_int 0)) )
(@ let214 term.x_41
(@ let215 (*_Real (term_int_to_real (a_int (~ 1)) ) let214)
(@ let216 (+_Real let215 (term_int_to_real term.termITE_30))
(@ let217 (>=_Real let216 (term_int_to_real (a_int 0)) )
(@ let218 (*_Int let12 let128)
(@ let219 (+_Real let214 (term_int_to_real (*_Int let12 let128)))
(@ let220 (>=_Real let219 (term_int_to_real (a_int 0)) )
(@ let221 term.x_45
(@ let222 (*_Real (term_int_to_real (a_int (~ 1)) ) let221)
(@ let223 (+_Real let222 (term_int_to_real term.termITE_29))
(@ let224 (>=_Real let223 (term_int_to_real (a_int 0)) )
(@ let225 (*_Int let12 let130)
(@ let226 (+_Real let221 (term_int_to_real (*_Int let12 let130)))
(@ let227 (>=_Real let226 (term_int_to_real (a_int 0)) )
(@ let228 term.x_46
(@ let229 (*_Real (term_int_to_real (a_int (~ 1)) ) let228)
(@ let230 (+_Real let229 (term_int_to_real term.termITE_29))
(@ let231 (>=_Real let230 (term_int_to_real (a_int 0)) )
(@ let232 (+_Real let228 (term_int_to_real (*_Int let12 let130)))
(@ let233 (>=_Real let232 (term_int_to_real (a_int 0)) )
(@ let234 term.termITE_26
(@ let235 (*_Real (term_int_to_real (a_int (~ 1)) ) let234)
(@ let236 (+_Real let101 (+_Real let157 let235))
(@ let237 (>=_Real let236 (term_int_to_real (a_int 0)) )
(@ let238 (*_Real (term_int_to_real (a_int (~ 1)) ) let157)
(@ let239 (+_Real let100 (+_Real let238 let234))
(@ let240 (>=_Real let239 (term_int_to_real (a_int 0)) )
(@ let241 term.termITE_21
(@ let242 (*_Real (term_int_to_real (a_int (~ 1)) ) let241)
(@ let243 (+_Real let101 (+_Real let151 let242))
(@ let244 (>=_Real let243 (term_int_to_real (a_int 0)) )
(@ let245 (*_Real (term_int_to_real (a_int (~ 1)) ) let151)
(@ let246 (+_Real let100 (+_Real let245 let241))
(@ let247 (>=_Real let246 (term_int_to_real (a_int 0)) )
(@ let248 (>=_Real let121 (term_int_to_real (a_int 1)) )
(@ let249 (>=_Real let122 (term_int_to_real (a_int (~ 1)) ))
(@ let250 x_12
(@ let251 x_13
(@ let252 (iff (p_app let250) (p_app let251) )
(@ let253 x_28
(@ let254 x_29
(@ let255 (iff (p_app let253) (p_app let254) )
(@ let256 x_15
(@ let257 x_16
(@ let258 x_31
(@ let259 (and let28 (p_app let258))
(@ let260 (or (p_app let257) let259)
(@ let261 (iff (p_app let256) let260)
(@ let262 x_30
(@ let263 (or (p_app let258) let28)
(@ let264 (iff (p_app let262) let263)
(@ let265 x_17
(@ let266 x_18
(@ let267 x_33
(@ let268 (*_Real (term_int_to_real (a_int (~ 1)) ) let79)
(@ let269 (+_Real let112 let268)
(@ let270 (>=_Real let269 (term_int_to_real (a_int 0)) )
(@ let271 (not let270)
(@ let272 (+_Real let22 let268)
(@ let273 (>=_Real let272 (term_int_to_real (a_int 0)) )
(@ let274 (and let271 let273)
(@ let275 (and (p_app let267) let274)
(@ let276 (or (p_app let266) let275)
(@ let277 (iff (p_app let265) let276)
(@ let278 x_19
(@ let279 x_20
(@ let280 x_35
(@ let281 (*_Real (term_int_to_real (a_int (~ 1)) ) let77)
(@ let282 (+_Real let112 let281)
(@ let283 (>=_Real let282 (term_int_to_real (a_int 0)) )
(@ let284 (not let283)
(@ let285 (+_Real let22 let281)
(@ let286 (>=_Real let285 (term_int_to_real (a_int 0)) )
(@ let287 (and let284 let286)
(@ let288 (and (p_app let280) let287)
(@ let289 (or (p_app let279) let288)
(@ let290 (iff (p_app let278) let289)
(@ let291 x_34
(@ let292 (or (p_app let280) let287)
(@ let293 (iff (p_app let291) let292)
(@ let294 x_32
(@ let295 (or (p_app let267) let274)
(@ let296 (iff (p_app let294) let295)
(@ let297 (*_Real (term_int_to_real (a_int (~ 1)) ) let112)
(@ let298 (+_Real let37 (+_Real let297 let32))
(@ let299 (>=_Real let298 (term_int_to_real (a_int 0)) )
(@ let300 (not let299)
(@ let301 (*_Real (term_int_to_real (a_int (~ 1)) ) let22)
(@ let302 (+_Real let32 let301)
(@ let303 (>=_Real let302 (term_int_to_real (a_int 0)) )
(@ let304 (and let35 let303)
(@ let305 (and let300 let304)
(@ let306 (+_Real let33 let25)
(@ let307 (>=_Real let306 (term_int_to_real (a_int 0)) )
(@ let308 (not let307)
(@ let309 (+_Real let36 (+_Real let112 let26))
(@ let310 (>=_Real let309 (term_int_to_real (a_int 0)) )
(@ let311 (not (p_app let258))
(@ let312 (not (p_app let257))
(@ let313 (+_Real let301 let25)
(@ let314 (>=_Real let313 (term_int_to_real (a_int 0)) )
(@ let315 (and let314 let28)
(@ let316 (and let312 let315)
(@ let317 (and let311 let316)
(@ let318 (and let310 let317)
(@ let319 (and let308 let318)
(@ let320 (+_Real let33 let79)
(@ let321 (>=_Real let320 (term_int_to_real (a_int 0)) )
(@ let322 (not let321)
(@ let323 (+_Real let36 (+_Real let112 let268))
(@ let324 (>=_Real let323 (term_int_to_real (a_int 0)) )
(@ let325 (not (p_app let267))
(@ let326 (not (p_app let266))
(@ let327 (+_Real let301 let79)
(@ let328 (>=_Real let327 (term_int_to_real (a_int 0)) )
(@ let329 (and let328 let273)
(@ let330 (and let326 let329)
(@ let331 (and let325 let330)
(@ let332 (and let324 let331)
(@ let333 (and let322 let332)
(@ let334 (+_Real let33 let77)
(@ let335 (>=_Real let334 (term_int_to_real (a_int 0)) )
(@ let336 (not let335)
(@ let337 (+_Real let36 (+_Real let112 let281))
(@ let338 (>=_Real let337 (term_int_to_real (a_int 0)) )
(@ let339 (not (p_app let280))
(@ let340 (not (p_app let279))
(@ let341 (+_Real let301 let77)
(@ let342 (>=_Real let341 (term_int_to_real (a_int 0)) )
(@ let343 (and let342 let286)
(@ let344 (and let340 let343)
(@ let345 (and let339 let344)
(@ let346 (and let338 let345)
(@ let347 (and let336 let346)
(@ let348 (or let333 let347)
(@ let349 (or let319 let348)
(@ let350 (or let305 let349)
(@ let351 (not let310)
(@ let352 (or let351 (p_app let258))
(@ let353 (or (p_app let257) let352)
(@ let354 (or let28 let353)
(@ let355 (not let338)
(@ let356 (or let283 let355)
(@ let357 (or (p_app let280) let356)
(@ let358 (or (p_app let279) let357)
(@ let359 (or let286 let358)
(@ let360 (not let324)
(@ let361 (or let270 let360)
(@ let362 (or (p_app let267) let361)
(@ let363 (or (p_app let266) let362)
(@ let364 (or let273 let363)
(@ let365 x_36
(@ let366 (not (p_app let365))
(@ let367 (and let312 let311)
(@ let368 (and let310 let367)
(@ let369 (and let271 let326)
(@ let370 (and let325 let369)
(@ let371 (and let324 let370)
(@ let372 (and let284 let340)
(@ let373 (and let339 let372)
(@ let374 (and let338 let373)
(@ let375 (or let371 let374)
(@ let376 (or let368 let375)
(@ let377 (and let249 let248)
(@ let378 (and let376 let377)
(@ let379 (and let366 let378)
(@ let380 (and let364 let379)
(@ let381 (and let359 let380)
(@ let382 (and let354 let381)
(@ let383 (and let350 let382)
(@ let384 (and let296 let383)
(@ let385 (and let293 let384)
(@ let386 (and let290 let385)
(@ let387 (and let277 let386)
(@ let388 (and let264 let387)
(@ let389 (and let261 let388)
(@ let390 (iff (p_app let262) (p_app let258) )
(@ let391 (iff (p_app let294) (p_app let267) )
(@ let392 (iff (p_app let291) (p_app let280) )
(@ let393 (or (p_app let258) (p_app let257))
(@ let394 (or let351 let393)
(@ let395 (or let283 (p_app let280))
(@ let396 (or (p_app let279) let395)
(@ let397 (or let355 let396)
(@ let398 (or let270 (p_app let267))
(@ let399 (or (p_app let266) let398)
(@ let400 (or let360 let399)
(@ let401 (+_Real let37 (+_Real let297 let22))
(@ let402 (>=_Real let401 (term_int_to_real (a_int 0)) )
(@ let403 (+_Real let36 (+_Real let112 let301))
(@ let404 (>=_Real let403 (term_int_to_real (a_int 0)) )
(@ let405 (and let404 let377)
(@ let406 (and let402 let405)
(@ let407 (and let400 let406)
(@ let408 (and let397 let407)
(@ let409 (and let394 let408)
(@ let410 (and (p_app let365) let409)
(@ let411 (and let290 let410)
(@ let412 (and let277 let411)
(@ let413 (and let261 let412)
(@ let414 (and let392 let413)
(@ let415 (and let391 let414)
(@ let416 (and let390 let415)
(@ let417 (or let389 let416)
(@ let418 (*_Real (term_int_to_real (a_int (~ 1)) ) let108)
(@ let419 (+_Real let418 let83)
(@ let420 (>=_Real let419 (term_int_to_real (a_int 0)) )
(@ let421 (*_Real (term_int_to_real (a_int (~ 1)) ) let83)
(@ let422 (+_Real let108 let421)
(@ let423 (>=_Real let422 (term_int_to_real (a_int 0)) )
(@ let424 (+_Real let105 let100)
(@ let425 (>=_Real let424 (term_int_to_real (a_int 0)) )
(@ let426 (+_Real let104 let101)
(@ let427 (>=_Real let426 (term_int_to_real (a_int 0)) )
(@ let428 (+_Real let97 let55)
(@ let429 (>=_Real let428 (term_int_to_real (a_int 0)) )
(@ let430 (+_Real let96 let93)
(@ let431 (>=_Real let430 (term_int_to_real (a_int 0)) )
(@ let432 (+_Real let90 let52)
(@ let433 (>=_Real let432 (term_int_to_real (a_int 0)) )
(@ let434 (+_Real let89 let85)
(@ let435 (>=_Real let434 (term_int_to_real (a_int 0)) )
(@ let436 (and let433 let435)
(@ let437 (and let431 let436)
(@ let438 (and let429 let437)
(@ let439 (and let427 let438)
(@ let440 (and let425 let439)
(@ let441 (and let423 let440)
(@ let442 (and let420 let441)
(@ let443 (and let417 let442)
(@ let444 (and let255 let443)
(@ let445 (and let10 let444)
(@ let446 (and let9 let445)
(@ let447 (and let8 let446)
(@ let448 (and let252 let447)
(@ let449 (and let169 let107)
(@ let450 (and let106 let172)
(@ let451 (or (p_app let257) let450)
(@ let452 (or let449 let451)
(@ let453 (iff (p_app let256) let452)
(@ let454 (and let192 let92)
(@ let455 (and let91 let195)
(@ let456 (or (p_app let279) let455)
(@ let457 (or let454 let456)
(@ let458 (iff (p_app let278) let457)
(@ let459 (and let181 let99)
(@ let460 (and let98 let184)
(@ let461 (or (p_app let266) let460)
(@ let462 (or let459 let461)
(@ let463 (iff (p_app let265) let462)
(@ let464 (+_Real let32 let418)
(@ let465 (>=_Real let464 (term_int_to_real (a_int 0)) )
(@ let466 term.termITE_19
(@ let467 (+_Real let105 let466)
(@ let468 (>=_Real let467 (term_int_to_real (a_int 0)) )
(@ let469 (*_Real (term_int_to_real (a_int (~ 1)) ) let466)
(@ let470 (+_Real let104 let469)
(@ let471 (>=_Real let470 (term_int_to_real (a_int 0)) )
(@ let472 term.termITE_15
(@ let473 (+_Real let90 let472)
(@ let474 (>=_Real let473 (term_int_to_real (a_int 0)) )
(@ let475 (*_Real (term_int_to_real (a_int (~ 1)) ) let472)
(@ let476 (+_Real let89 let475)
(@ let477 (>=_Real let476 (term_int_to_real (a_int 0)) )
(@ let478 term.termITE_17
(@ let479 (+_Real let97 let478)
(@ let480 (>=_Real let479 (term_int_to_real (a_int 0)) )
(@ let481 (*_Real (term_int_to_real (a_int (~ 1)) ) let478)
(@ let482 (+_Real let96 let481)
(@ let483 (>=_Real let482 (term_int_to_real (a_int 0)) )
(@ let484 (+_Real let301 let108)
(@ let485 (>=_Real let484 (term_int_to_real (a_int 0)) )
(@ let486 (+_Real let22 let418)
(@ let487 (>=_Real let486 (term_int_to_real (a_int 0)) )
(@ let488 (and let204 let124)
(@ let489 (and let487 let488)
(@ let490 (and let485 let489)
(@ let491 (and let483 let490)
(@ let492 (and let480 let491)
(@ let493 (and let477 let492)
(@ let494 (and let474 let493)
(@ let495 (and let471 let494)
(@ let496 (and let468 let495)
(@ let497 (and let423 let496)
(@ let498 (and let420 let497)
(@ let499 (and let465 let498)
(@ let500 (and (p_app let253) let499)
(@ let501 (and let463 let500)
(@ let502 (and let458 let501)
(@ let503 (and let453 let502)
(@ let504 (iff (p_app let256) let451)
(@ let505 (iff (p_app let278) let456)
(@ let506 (iff (p_app let265) let461)
(@ let507 (not let465)
(@ let508 term.termITE_13
(@ let509 (+_Real let105 let508)
(@ let510 (>=_Real let509 (term_int_to_real (a_int 0)) )
(@ let511 (*_Real (term_int_to_real (a_int (~ 1)) ) let508)
(@ let512 (+_Real let104 let511)
(@ let513 (>=_Real let512 (term_int_to_real (a_int 0)) )
(@ let514 (and let303 let488)
(@ let515 (and let35 let514)
(@ let516 (and let483 let515)
(@ let517 (and let480 let516)
(@ let518 (and let477 let517)
(@ let519 (and let474 let518)
(@ let520 (and let513 let519)
(@ let521 (and let510 let520)
(@ let522 (and let423 let521)
(@ let523 (and let420 let522)
(@ let524 (and let507 let523)
(@ let525 (and let506 let524)
(@ let526 (and let505 let525)
(@ let527 (and let504 let526)
(@ let528 (and let255 let527)
(@ let529 (or let528 let503)
(@ let530 x_37
(@ let531 (iff (p_app let365) (p_app let530) )
(@ let532 (and let391 let392)
(@ let533 (and let390 let532)
(@ let534 (and let529 let533)
(@ let535 (and let531 let534)
(@ let536 (and let10 let535)
(@ let537 (and let9 let536)
(@ let538 (and let8 let537)
(@ let539 (and let252 let538)
(@ let540 (>=_Real let121 (term_int_to_real (a_int 2)) )
(@ let541 (iff (p_app let256) (p_app let257) )
(@ let542 (iff (p_app let265) (p_app let266) )
(@ let543 (iff (p_app let278) (p_app let279) )
(@ let544 term.termITE_3
(@ let545 (*_Real (term_int_to_real (a_int (~ 1)) ) let544)
(@ let546 (a_real 1/2) 
(@ let547 term.termITE_8
(@ let548 (*_Real let546 let547)
(@ let549 (+_Real let545 let548)
(@ let550 (>=_Real let549 (term_int_to_real (a_int 0)) )
(@ let551 (not let550)
(@ let552 (+_Real let297 let22)
(@ let553 (>=_Real let552 (term_int_to_real (a_int 0)) )
(@ let554 (+_Real let112 let301)
(@ let555 (>=_Real let554 (term_int_to_real (a_int 0)) )
(@ let556 (and let123 let540)
(@ let557 (and let555 let556)
(@ let558 (and let553 let557)
(@ let559 (and let551 let558)
(@ let560 (and (p_app let250) let559)
(@ let561 (and let543 let560)
(@ let562 (and let542 let561)
(@ let563 (and let541 let562)
(@ let564 (and let10 let563)
(@ let565 (and let9 let564)
(@ let566 (and let8 let565)
(@ let567 (or (p_app let3) let315)
(@ let568 (iff (p_app let6) let567)
(@ let569 (or (p_app let2) let343)
(@ let570 (iff (p_app let5) let569)
(@ let571 (or (p_app let1) let329)
(@ let572 (iff (p_app let4) let571)
(@ let573 (and let57 let316)
(@ let574 (and let308 let573)
(@ let575 (and let58 let330)
(@ let576 (and let271 let575)
(@ let577 (and let322 let576)
(@ let578 (and let59 let344)
(@ let579 (and let284 let578)
(@ let580 (and let336 let579)
(@ let581 (or let577 let580)
(@ let582 (or let574 let581)
(@ let583 (or let304 let582)
(@ let584 (or (p_app let3) (p_app let257))
(@ let585 (or let314 let584)
(@ let586 (or let283 (p_app let2))
(@ let587 (or (p_app let279) let586)
(@ let588 (or let342 let587)
(@ let589 (or let270 (p_app let1))
(@ let590 (or (p_app let266) let589)
(@ let591 (or let328 let590)
(@ let592 (not (p_app let250))
(@ let593 (and let550 let556)
(@ let594 (and let592 let593)
(@ let595 (and let591 let594)
(@ let596 (and let588 let595)
(@ let597 (and let585 let596)
(@ let598 (and let583 let597)
(@ let599 (and let572 let598)
(@ let600 (and let570 let599)
(@ let601 (and let568 let600)
(@ let602 (and let543 let601)
(@ let603 (and let542 let602)
(@ let604 (and let541 let603)
(@ let605 (or let604 let566)
(@ let606 (and let605 let442)
(@ let607 (and let255 let606)
(@ let608 (and let392 let607)
(@ let609 (and let391 let608)
(@ let610 (and let390 let609)
(@ let611 (and let531 let610)
(@ let612 term.termITE_2
(@ let613 (+_Real let122 let612)
(@ let614 (>=_Real let613 (term_int_to_real (a_int 0)) )
(@ let615 (*_Real (term_int_to_real (a_int (~ 1)) ) let612)
(@ let616 (+_Real let121 let615)
(@ let617 (>=_Real let616 (term_int_to_real (a_int 0)) )
(@ let618 (and let614 let617)
(@ let619 (and let201 let618)
(@ let620 (and let202 let619)
(@ let621 term.termITE_1
(@ let622 (+_Real let122 let621)
(@ let623 (>=_Real let622 (term_int_to_real (a_int 0)) )
(@ let624 (*_Real (term_int_to_real (a_int (~ 1)) ) let621)
(@ let625 (+_Real let121 let624)
(@ let626 (>=_Real let625 (term_int_to_real (a_int 0)) )
(@ let627 (and let623 let626)
(@ let628 (and let117 let627)
(@ let629 (and let205 let628)
(@ let630 (+_Real let118 let121)
(@ let631 (>=_Real let630 (term_int_to_real (a_int 0)) )
(@ let632 (+_Real let116 let122)
(@ let633 (>=_Real let632 (term_int_to_real (a_int 0)) )
(@ let634 (not let206)
(@ let635 (not let203)
(@ let636 (and let631 let633)
(@ let637 (and let635 let636)
(@ let638 (and let634 let637)
(@ let639 (+_Real let268 let46)
(@ let640 (>=_Real let639 (term_int_to_real (a_int 0)) )
(@ let641 (+_Real let79 let47)
(@ let642 (>=_Real let641 (term_int_to_real (a_int 0)) )
(@ let643 (+_Real let281 let39)
(@ let644 (>=_Real let643 (term_int_to_real (a_int 0)) )
(@ let645 (+_Real let77 let40)
(@ let646 (>=_Real let645 (term_int_to_real (a_int 0)) )
(@ let647 (+_Real let33 let38)
(@ let648 (>=_Real let647 (term_int_to_real (a_int 0)) )
(@ let649 (+_Real let32 let43)
(@ let650 (>=_Real let649 (term_int_to_real (a_int 0)) )
(@ let651 (*_Real (term_int_to_real (a_int (~ 1)) ) let65)
(@ let652 (+_Real let33 (+_Real let38 let651))
(@ let653 (>=_Real let652 (term_int_to_real (a_int 0)) )
(@ let654 (+_Real let32 (+_Real let43 let65))
(@ let655 (>=_Real let654 (term_int_to_real (a_int 0)) )
(@ let656 (+_Real let26 let18)
(@ let657 (>=_Real let656 (term_int_to_real (a_int 0)) )
(@ let658 (+_Real let25 let29)
(@ let659 (>=_Real let658 (term_int_to_real (a_int 0)) )
(@ let660 (*_Real (term_int_to_real (a_int (~ 1)) ) let75)
(@ let661 (+_Real let660 let11)
(@ let662 (>=_Real let661 (term_int_to_real (a_int 0)) )
(@ let663 (+_Real let75 let19)
(@ let664 (>=_Real let663 (term_int_to_real (a_int 0)) )
(@ let665 (*_Real (term_int_to_real (a_int (~ 1)) ) let73)
(@ let666 (+_Real let665 let13)
(@ let667 (>=_Real let666 (term_int_to_real (a_int 0)) )
(@ let668 (+_Real let73 let14)
(@ let669 (>=_Real let668 (term_int_to_real (a_int 0)) )

 ;; Printing aliasing declarations 


 ;; Rewrites for Lemmas 

 ;; In the preprocessor we trust 
(th_let_pf _ (trust_f (or (not let540) (not let249))) (\ .PA3872
(th_let_pf _ (trust_f (and let127 (and (not let145) (and let129 (and (not let146) (and let131 (and (not let147) (and let133 (and (not let148) (and let136 (and (not let150) (and let155 (and let156 (and let161 (and let162 (and let138 (and (not let163) (and let140 (and (not let164) (and let142 (and (not let165) (and let144 (and (not let166) (and (or (p_app let6) (or (p_app let4) (p_app let5) )) (and (or (and (not let17) (and (not let21) (and (not let24) (and let28 (not let31) )))) (and (not let28) (and let667 (and let669 (and let662 (and let664 (and let657 let659 ))))))) (and (or (and (p_app let7) (and let35 (and let653 let655 ))) (and (not let35) (and (not (p_app let7)) (and let648 let650 )))) (and (or (and (not let42) (and let35 (not let45) )) (and (not let35) (and let644 let646 ))) (and (or (and (not let49) (and let35 (not let51) )) (and (not let35) (and let640 let642 ))) (and (or let638 (or let629 let620 )) (and (or let611 (or let539 let448 )) (and (or let634 let61) (and (or (not let488) (and (not (p_app let6)) (and (not (p_app let4)) (not (p_app let5)) ))) (and (or let635 let61) (and let62 (and let63 (and let64 (and let66 (and (not let70) (and let71 (and let72 (and let74 (and let76 (and let78 (and let80 (and let81 (and let82 (and let84 (and let87 (and let88 (and (or (and let87 let54) (or (and let200 let199) (or (and let198 let88) (and let197 let196) ))) (and let91 (and let92 (and (or let455 (or (and let194 let193) (or let454 (and let191 let190) ))) (and let94 (and let95 (and (or (and let94 let56) (or (and let189 let188) (or (and let187 let95) (and let186 let185) ))) (and let98 (and let99 (and (or let460 (or (and let183 let182) (or let459 (and let180 let179) ))) (and let102 (and let103 (and (or (and let102 let178) (or (and let177 let176) (or (and let175 let103) (and let174 let173) ))) (and let106 (and let107 (and (or let450 (or (and let171 let170) (or let449 (and let168 let167) ))) (and let109 (and let110 (and let111 (and let113 (and let114 (and (not let115) (and let117 (and let120 (and let123 (and let124 (and let249 (and let248 (and let244 (and let247 (and let237 (and let240 (and let231 (and let233 (and let224 (and let227 (and let217 (and let220 (and let210 let213 )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (\ .PA2796
(th_let_pf _ (trust_f (or (not let204) (not let248))) (\ .PA3870

;; Printing mapping from preprocessed assertions into atoms 
(decl_atom (p_app let1) (\ .v110 (\ .a110
(decl_atom (p_app let2) (\ .v104 (\ .a104
(decl_atom (p_app let3) (\ .v99 (\ .a99
(decl_atom (p_app let4) (\ .v25 (\ .a25
(decl_atom (p_app let5) (\ .v26 (\ .a26
(decl_atom (p_app let6) (\ .v24 (\ .a24
(decl_atom (p_app let7) (\ .v40 (\ .a40
(decl_atom let8 (\ .v135 (\ .a135
(decl_atom let9 (\ .v136 (\ .a136
(decl_atom let10 (\ .v137 (\ .a137
(decl_atom let17 (\ .v27 (\ .a27
(decl_atom let21 (\ .v28 (\ .a28
(decl_atom let24 (\ .v29 (\ .a29
(decl_atom let28 (\ .v30 (\ .a30
(decl_atom let31 (\ .v31 (\ .a31
(decl_atom let35 (\ .v41 (\ .a41
(decl_atom let42 (\ .v48 (\ .a48
(decl_atom let45 (\ .v49 (\ .a49
(decl_atom let49 (\ .v54 (\ .a54
(decl_atom let51 (\ .v55 (\ .a55
(decl_atom let54 (\ .v263 (\ .a263
(decl_atom let56 (\ .v281 (\ .a281
(decl_atom let61 (\ .v244 (\ .a244
(decl_atom let62 (\ .v247 (\ .a247
(decl_atom let63 (\ .v248 (\ .a248
(decl_atom let64 (\ .v249 (\ .a249
(decl_atom let66 (\ .v250 (\ .a250
(decl_atom let70 (\ .v251 (\ .a251
(decl_atom let71 (\ .v252 (\ .a252
(decl_atom let72 (\ .v253 (\ .a253
(decl_atom let74 (\ .v254 (\ .a254
(decl_atom let76 (\ .v255 (\ .a255
(decl_atom let78 (\ .v256 (\ .a256
(decl_atom let80 (\ .v257 (\ .a257
(decl_atom let81 (\ .v258 (\ .a258
(decl_atom let82 (\ .v259 (\ .a259
(decl_atom let84 (\ .v260 (\ .a260
(decl_atom let87 (\ .v261 (\ .a261
(decl_atom let88 (\ .v262 (\ .a262
(decl_atom let91 (\ .v158 (\ .a158
(decl_atom let92 (\ .v184 (\ .a184
(decl_atom let94 (\ .v279 (\ .a279
(decl_atom let95 (\ .v280 (\ .a280
(decl_atom let98 (\ .v163 (\ .a163
(decl_atom let99 (\ .v189 (\ .a189
(decl_atom let102 (\ .v297 (\ .a297
(decl_atom let103 (\ .v298 (\ .a298
(decl_atom let106 (\ .v153 (\ .a153
(decl_atom let107 (\ .v179 (\ .a179
(decl_atom let109 (\ .v315 (\ .a315
(decl_atom let110 (\ .v316 (\ .a316
(decl_atom let111 (\ .v317 (\ .a317
(decl_atom let113 (\ .v318 (\ .a318
(decl_atom let114 (\ .v319 (\ .a319
(decl_atom let115 (\ .v320 (\ .a320
(decl_atom let117 (\ .v61 (\ .a61
(decl_atom let120 (\ .v321 (\ .a321
(decl_atom let123 (\ .v132 (\ .a132
(decl_atom let124 (\ .v176 (\ .a176
(decl_atom let127 (\ .v2 (\ .a2
(decl_atom let129 (\ .v4 (\ .a4
(decl_atom let131 (\ .v6 (\ .a6
(decl_atom let133 (\ .v8 (\ .a8
(decl_atom let136 (\ .v10 (\ .a10
(decl_atom let138 (\ .v16 (\ .a16
(decl_atom let140 (\ .v18 (\ .a18
(decl_atom let142 (\ .v20 (\ .a20
(decl_atom let144 (\ .v22 (\ .a22
(decl_atom let145 (\ .v3 (\ .a3
(decl_atom let146 (\ .v5 (\ .a5
(decl_atom let147 (\ .v7 (\ .a7
(decl_atom let148 (\ .v9 (\ .a9
(decl_atom let150 (\ .v11 (\ .a11
(decl_atom let155 (\ .v12 (\ .a12
(decl_atom let156 (\ .v13 (\ .a13
(decl_atom let161 (\ .v14 (\ .a14
(decl_atom let162 (\ .v15 (\ .a15
(decl_atom let163 (\ .v17 (\ .a17
(decl_atom let164 (\ .v19 (\ .a19
(decl_atom let165 (\ .v21 (\ .a21
(decl_atom let166 (\ .v23 (\ .a23
(decl_atom let167 (\ .v313 (\ .a313
(decl_atom let168 (\ .v312 (\ .a312
(decl_atom let169 (\ .v178 (\ .a178
(decl_atom let170 (\ .v310 (\ .a310
(decl_atom let171 (\ .v309 (\ .a309
(decl_atom let172 (\ .v154 (\ .a154
(decl_atom let173 (\ .v307 (\ .a307
(decl_atom let174 (\ .v306 (\ .a306
(decl_atom let175 (\ .v304 (\ .a304
(decl_atom let176 (\ .v302 (\ .a302
(decl_atom let177 (\ .v301 (\ .a301
(decl_atom let178 (\ .v299 (\ .a299
(decl_atom let179 (\ .v295 (\ .a295
(decl_atom let180 (\ .v294 (\ .a294
(decl_atom let181 (\ .v188 (\ .a188
(decl_atom let182 (\ .v292 (\ .a292
(decl_atom let183 (\ .v291 (\ .a291
(decl_atom let184 (\ .v164 (\ .a164
(decl_atom let185 (\ .v289 (\ .a289
(decl_atom let186 (\ .v288 (\ .a288
(decl_atom let187 (\ .v286 (\ .a286
(decl_atom let188 (\ .v284 (\ .a284
(decl_atom let189 (\ .v283 (\ .a283
(decl_atom let190 (\ .v277 (\ .a277
(decl_atom let191 (\ .v276 (\ .a276
(decl_atom let192 (\ .v183 (\ .a183
(decl_atom let193 (\ .v274 (\ .a274
(decl_atom let194 (\ .v273 (\ .a273
(decl_atom let195 (\ .v159 (\ .a159
(decl_atom let196 (\ .v271 (\ .a271
(decl_atom let197 (\ .v270 (\ .a270
(decl_atom let198 (\ .v268 (\ .a268
(decl_atom let199 (\ .v266 (\ .a266
(decl_atom let200 (\ .v265 (\ .a265
(decl_atom let201 (\ .v64 (\ .a64
(decl_atom let202 (\ .v63 (\ .a63
(decl_atom let203 (\ .v65 (\ .a65
(decl_atom let204 (\ .v175 (\ .a175
(decl_atom let205 (\ .v60 (\ .a60
(decl_atom let206 (\ .v62 (\ .a62
(decl_atom let210 (\ .v332 (\ .a332
(decl_atom let213 (\ .v333 (\ .a333
(decl_atom let217 (\ .v330 (\ .a330
(decl_atom let220 (\ .v331 (\ .a331
(decl_atom let224 (\ .v328 (\ .a328
(decl_atom let227 (\ .v329 (\ .a329
(decl_atom let231 (\ .v326 (\ .a326
(decl_atom let233 (\ .v327 (\ .a327
(decl_atom let237 (\ .v324 (\ .a324
(decl_atom let240 (\ .v325 (\ .a325
(decl_atom let244 (\ .v322 (\ .a322
(decl_atom let247 (\ .v323 (\ .a323
(decl_atom let248 (\ .v234 (\ .a234
(decl_atom let249 (\ .v233 (\ .a233
(decl_atom let448 (\ .v243 (\ .a243
(decl_atom let503 (\ .v197 (\ .a197
(decl_atom let528 (\ .v177 (\ .a177
(decl_atom let529 (\ .v198 (\ .a198
(decl_atom let539 (\ .v199 (\ .a199
(decl_atom let540 (\ .v133 (\ .a133
(decl_atom let566 (\ .v140 (\ .a140
(decl_atom let604 (\ .v134 (\ .a134
(decl_atom let605 (\ .v141 (\ .a141
(decl_atom let611 (\ .v150 (\ .a150
(decl_atom let620 (\ .v74 (\ .a74
(decl_atom let629 (\ .v71 (\ .a71
(decl_atom let631 (\ .v66 (\ .a66
(decl_atom let633 (\ .v67 (\ .a67
(decl_atom let638 (\ .v68 (\ .a68
(decl_atom let640 (\ .v57 (\ .a57
(decl_atom let642 (\ .v58 (\ .a58
(decl_atom let644 (\ .v51 (\ .a51
(decl_atom let646 (\ .v52 (\ .a52
(decl_atom let648 (\ .v45 (\ .a45
(decl_atom let650 (\ .v46 (\ .a46
(decl_atom let653 (\ .v42 (\ .a42
(decl_atom let655 (\ .v43 (\ .a43
(decl_atom let657 (\ .v37 (\ .a37
(decl_atom let659 (\ .v38 (\ .a38
(decl_atom let662 (\ .v35 (\ .a35
(decl_atom let664 (\ .v36 (\ .a36
(decl_atom let667 (\ .v33 (\ .a33
(decl_atom let669 (\ .v34 (\ .a34
(satlem _ _ (ast _ _ _ .a24 (\ .l49 (asf _ _ _ .a99 (\ .l198 (ast _ _ _ .a135 (\ .l271
(clausify_false
(contra _
(or_elim_1 _ _ (not_not_intro _ .l49) (iff_elim_1 _ _ .l271))
.l198)
)
)
))))) (\ .pb212
(satlem _ _ (asf _ _ _ .a136 (\ .l272 (ast _ _ _ .a243 (\ .l487 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l487))) .l272)))))) (\ .pb544
(satlem _ _ (ast _ _ _ .a110 (\ .l221 (ast _ _ _ .a244 (\ .l489 (clausify_false (contra _ .l221 (and_elim_1 _ _ (and_elim_2 _ _ .l489)))))))) (\ .pb559
(satlem _ _ (ast _ _ _ .a198 (\ .l397 (asf _ _ _ .a197 (\ .l394 (asf _ _ _ .a177 (\ .l354 (clausify_false (contra _ (or_elim_1 _ _ .l354 .l397) .l394)))))))) (\ .pb360
(satlem _ _ (ast _ _ _ .a175 (\ .l351 (ast _ _ _ .a234 (\ .l469 (clausify_false (contra _ .l469 (or_elim_1 _ _ (not_not_intro _ .l351) .PA3870))))))) (\ .pb930
(satlem _ _ (ast _ _ _ .a199 (\ .l399 (asf _ _ _ .a198 (\ .l396 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l399)))))) .l396)))))) (\ .pb366
(satlem _ _ (asf _ _ _ .a67 (\ .l134 (ast _ _ _ .a68 (\ .l137 (clausify_false (contra _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l137))) .l134)))))) (\ .pb80
(satlem _ _ (ast _ _ _ .a133 (\ .l267 (ast _ _ _ .a233 (\ .l467 (clausify_false (contra _ .l467 (or_elim_1 _ _ (not_not_intro _ .l267) .PA3872))))))) (\ .pb931
(satlem _ _ (asf _ _ _ .a234 (\ .l468 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) .l468)))) (\ .pb663
(satlem _ _ (ast _ _ _ .a99 (\ .l199 (ast _ _ _ .a244 (\ .l489 (clausify_false (contra _ .l199 (and_elim_1 _ _ .l489))))))) (\ .pb558
(satlem _ _ (asf _ _ _ .a64 (\ .l128 (ast _ _ _ .a74 (\ .l149 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ .l149)) .l128)))))) (\ .pb88
(satlem _ _ (ast _ _ _ .a65 (\ .l131 (asf _ _ _ .a244 (\ .l488 (clausify_false (contra _ (or_elim_1 _ _ (not_not_intro _ .l131) (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796))))))))))))))))))))))))))))))))) .l488)))))) (\ .pb571
(satlem _ _ (ast _ _ _ .a62 (\ .l125 (asf _ _ _ .a244 (\ .l488 (clausify_false (contra _ (or_elim_1 _ _ (not_not_intro _ .l125) (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796))))))))))))))))))))))))))))))) .l488)))))) (\ .pb562
(satlem _ _ (asf _ _ _ .a74 (\ .l148 (asf _ _ _ .a68 (\ .l136 (asf _ _ _ .a71 (\ .l142 (clausify_false (contra _ (or_elim_1 _ _ .l142 (or_elim_1 _ _ .l136 (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796)))))))))))))))))))))))))))))) .l148)))))))) (\ .pb92
(satlem _ _ (ast _ _ _ .a177 (\ .l355 (asf _ _ _ .a175 (\ .l350 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l355)))))))))))))))) .l350)))))) (\ .pb304
(satlem _ _ (ast _ _ _ .a134 (\ .l269 (asf _ _ _ .a133 (\ .l266 (clausify_false (contra _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l269))))))))))))) .l266)))))) (\ .pb210
(satlem _ _ (ast _ _ _ .a104 (\ .l209 (ast _ _ _ .a244 (\ .l489 (clausify_false (contra _ .l209 (and_elim_2 _ _ (and_elim_2 _ _ .l489)))))))) (\ .pb560
(satlem _ _ (ast _ _ _ .a64 (\ .l129 (ast _ _ _ .a63 (\ .l127 (asf _ _ _ .a65 (\ .l130 (clausify_false (contra _ .l129 (or_elim_1 _ _ (not_not_intro _ .l127) (not_and_elim _ _ .l130)))))))))) (\ .pb76
(satlem _ _ (asf _ _ _ .a66 (\ .l132 (ast _ _ _ .a68 (\ .l137 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l137))) .l132)))))) (\ .pb79
(satlem _ _ (ast _ _ _ .a26 (\ .l53 (asf _ _ _ .a104 (\ .l208 (ast _ _ _ .a137 (\ .l275 (clausify_false (contra _ (or_elim_1 _ _ (not_not_intro _ .l53) (iff_elim_1 _ _ .l275)) .l208)))))))) (\ .pb220
(satlem _ _ (ast _ _ _ .a71 (\ .l143 (asf _ _ _ .a60 (\ .l120 (clausify_false (contra _ (and_elim_1 _ _ .l143) .l120)))))) (\ .pb82
(satlem _ _ (asf _ _ _ .a135 (\ .l270 (ast _ _ _ .a243 (\ .l487 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ .l487)) .l270)))))) (\ .pb543
(satlem _ _ (ast _ _ _ .a197 (\ .l395 (asf _ _ _ .a175 (\ .l350 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l395)))))))))))))))) .l350)))))) (\ .pb355
(satlem _ _ (asf _ _ _ .a26 (\ .l52 (asf _ _ _ .a25 (\ .l50 (asf _ _ _ .a24 (\ .l48 (clausify_false (contra _ (or_elim_1 _ _ .l50 (or_elim_1 _ _ .l48 (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796))))))))))))))))))))))))) .l52)))))))) (\ .pb26
(satlem _ _ (ast _ _ _ .a60 (\ .l121 (asf _ _ _ .a62 (\ .l124 (ast _ _ _ .a61 (\ .l123 (clausify_false (contra _ .l123 (or_elim_1 _ _ (not_not_intro _ .l121) (not_and_elim _ _ .l124)))))))))) (\ .pb73
(satlem _ _ (ast _ _ _ .a25 (\ .l51 (asf _ _ _ .a110 (\ .l220 (ast _ _ _ .a136 (\ .l273 (clausify_false (contra _ (or_elim_1 _ _ (not_not_intro _ .l51) (iff_elim_1 _ _ .l273)) .l220)))))))) (\ .pb216
(satlem _ _ (asf _ _ _ .a137 (\ .l274 (ast _ _ _ .a243 (\ .l487 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l487)))) .l274)))))) (\ .pb545
(satlem _ _ (asf _ _ _ .a63 (\ .l126 (ast _ _ _ .a74 (\ .l149 (clausify_false (contra _ (and_elim_1 _ _ .l149) .l126)))))) (\ .pb87
(satlem _ _ (asf _ _ _ .a243 (\ .l486 (asf _ _ _ .a150 (\ .l300 (asf _ _ _ .a199 (\ .l398 (clausify_false (contra _ (or_elim_1 _ _ .l398 (or_elim_1 _ _ .l300 (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796))))))))))))))))))))))))))))))) .l486)))))))) (\ .pb557
(satlem _ _ (asf _ _ _ .a61 (\ .l122 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) .l122)))) (\ .pb658
(satlem _ _ (ast _ _ _ .a140 (\ .l281 (asf _ _ _ .a133 (\ .l266 (clausify_false (contra _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l281))))))))))) .l266)))))) (\ .pb235
(satlem _ _ (ast _ _ _ .a150 (\ .l301 (asf _ _ _ .a141 (\ .l282 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .l301)))))) .l282)))))) (\ .pb245
(satlem _ _ (asf _ _ _ .a233 (\ .l466 (clausify_false (contra _ (and_elim_1 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ (and_elim_2 _ _ .PA2796))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) .l466)))) (\ .pb662
(satlem _ _ (ast _ _ _ .a141 (\ .l283 (asf _ _ _ .a140 (\ .l280 (asf _ _ _ .a134 (\ .l268 (clausify_false (contra _ (or_elim_1 _ _ .l268 .l283) .l280)))))))) (\ .pb239
 ;; Theory Lemmas 

;; BB atom mapping


;; Bit-blasting definitional clauses 


 ;; Bit-blasting learned clauses 

(satlem _ _ (asf _ _ _ .a64 (\ .l128 (ast _ _ _ .a67 (\ .l135 (ast _ _ _ .a234 (\ .l469 
;; Farkas Proof ;;

;  Linear Polynomial Proof Conversions
  (@ pf_aff.l128 (aff_>_from_term _ _ _ _ 
    (is_aff_- _ _ _ _ _ 
        (is_aff_var_real x_0)
      (is_aff_const 1/1)) (pf_reified_arith_pred _ _ .l128))
  (@ pf_aff.l135 (aff_>=_from_term _ _ _ 
    (is_aff_- _ _ _ _ _ 
      (is_aff_+ _ _ _ _ _ 
        (is_aff_var_real x_0)
        (is_aff_mul_c_L _ _ _ (~ 1/1) (is_aff_var_real x_4)))
      (is_aff_const 0/1)) (pf_reified_arith_pred _ _ .l135))
  (@ pf_aff.l469 (aff_>=_from_term _ _ _ 
    (is_aff_- _ _ _ _ _ 
        (is_aff_var_real x_4)
      (is_aff_const 1/1)) (pf_reified_arith_pred _ _ .l469))
;  Farkas Combination
  (clausify_false (bounded_aff_contra _ _
    (bounded_aff_add _ _ _ _ _
       (bounded_aff_mul_c _ _ _ 1/1 pf_aff.l128) ; (not (>= x_0 1.0))
    (bounded_aff_add _ _ _ _ _
       (bounded_aff_mul_c _ _ _ 1/1 pf_aff.l135) ; (>= (+ x_0 (* (- 1.0) x_4)) 0.0)
    (bounded_aff_add _ _ _ _ _
       (bounded_aff_mul_c _ _ _ 1/1 pf_aff.l469) ; (>= x_4 1.0)
    bounded_aff_ax_0_>=_0))))))))))))))( \ .lemc1041
(satlem _ _ (asf _ _ _ .a63 (\ .l126 (ast _ _ _ .a66 (\ .l133 (ast _ _ _ .a233 (\ .l467 
;; Farkas Proof ;;

;  Linear Polynomial Proof Conversions
  (@ pf_aff.l126 (aff_>_from_term _ _ _ _ 
    (is_aff_- _ _ _ _ _ 
        (is_aff_mul_c_L _ _ _ (~ 1/1) (is_aff_var_real x_0))
      (is_aff_const (~ 1/1))) (pf_reified_arith_pred _ _ .l126))
  (@ pf_aff.l133 (aff_>=_from_term _ _ _ 
    (is_aff_- _ _ _ _ _ 
      (is_aff_+ _ _ _ _ _ 
        (is_aff_mul_c_L _ _ _ (~ 1/1) (is_aff_var_real x_0))
        (is_aff_var_real x_4))
      (is_aff_const 0/1)) (pf_reified_arith_pred _ _ .l133))
  (@ pf_aff.l467 (aff_>=_from_term _ _ _ 
    (is_aff_- _ _ _ _ _ 
        (is_aff_mul_c_L _ _ _ (~ 1/1) (is_aff_var_real x_4))
      (is_aff_const (~ 1/1))) (pf_reified_arith_pred _ _ .l467))
;  Farkas Combination
  (clausify_false (bounded_aff_contra _ _
    (bounded_aff_add _ _ _ _ _
       (bounded_aff_mul_c _ _ _ 1/1 pf_aff.l126) ; (not (>= (* (- 1.0) x_0) (- 1.0)))
    (bounded_aff_add _ _ _ _ _
       (bounded_aff_mul_c _ _ _ 1/1 pf_aff.l133) ; (>= (+ (* (- 1.0) x_0) x_4) 0.0)
    (bounded_aff_add _ _ _ _ _
       (bounded_aff_mul_c _ _ _ 1/1 pf_aff.l467) ; (>= (* (- 1.0) x_4) (- 1.0))
    bounded_aff_ax_0_>=_0))))))))))))))( \ .lemc1042
;; Printing final unsat proof 
(satlem_simplify _ _ _ (Q _ _ (Q _ _ (Q _ _ (Q _ _ (Q _ _ (Q _ _ .pb76 .lemc1042 .v63) .pb662 .v233) .lemc1041 .v64) .pb663 .v234) .pb80 .v67) .pb79 .v66) (\ .cl1043
(satlem_simplify _ _ _ (R _ _ (R _ _ (Q _ _ (R _ _ (R _ _ (R _ _ (Q _ _ (Q _ _ (Q _ _ .pb76 .pb88 .v64) .pb87 .v63) .pb92 .v74) .cl1043 .v68) .pb82 .v71) .pb73 .v60) .pb658 .v61) .pb571 .v65) .pb562 .v62) (\ .cl1044
(satlem_simplify _ _ _ (Q _ _ .pb560 .cl1044 .v244) (\ .cl1045
(satlem_simplify _ _ _ (Q _ _ .pb931 .pb662 .v233) (\ .cl1046
(satlem_simplify _ _ _ (R _ _ .pb235 .cl1046 .v133) (\ .cl1047
(satlem_simplify _ _ _ (R _ _ .pb210 .cl1046 .v133) (\ .cl1048
(satlem_simplify _ _ _ (R _ _ (R _ _ .pb239 .cl1047 .v140) .cl1048 .v134) (\ .cl1049
(satlem_simplify _ _ _ (R _ _ .pb245 .cl1049 .v141) (\ .cl1050
(satlem_simplify _ _ _ (Q _ _ .pb930 .pb663 .v234) (\ .cl1051
(satlem_simplify _ _ _ (R _ _ .pb355 .cl1051 .v175) (\ .cl1052
(satlem_simplify _ _ _ (R _ _ .pb304 .cl1051 .v175) (\ .cl1053
(satlem_simplify _ _ _ (R _ _ (R _ _ .pb360 .cl1052 .v197) .cl1053 .v177) (\ .cl1054
(satlem_simplify _ _ _ (R _ _ .pb366 .cl1054 .v198) (\ .cl1055
(satlem_simplify _ _ _ (R _ _ (R _ _ .pb557 .cl1050 .v150) .cl1055 .v199) (\ .cl1056
(satlem_simplify _ _ _ (Q _ _ .pb545 .cl1056 .v243) (\ .cl1057
(satlem_simplify _ _ _ (Q _ _ (R _ _ .pb220 .cl1045 .v104) .cl1057 .v137) (\ .cl1058
(satlem_simplify _ _ _ (Q _ _ .pb559 .cl1044 .v244) (\ .cl1059
(satlem_simplify _ _ _ (Q _ _ .pb544 .cl1056 .v243) (\ .cl1060
(satlem_simplify _ _ _ (Q _ _ (R _ _ .pb216 .cl1059 .v110) .cl1060 .v136) (\ .cl1061
(satlem_simplify _ _ _ (Q _ _ .pb558 .cl1044 .v244) (\ .cl1062
(satlem_simplify _ _ _ (Q _ _ .pb543 .cl1056 .v243) (\ .cl1063
(satlem_simplify _ _ _ (Q _ _ (R _ _ .pb212 .cl1062 .v99) .cl1063 .v135) (\ .cl1064
(satlem_simplify _ _ _ (R _ _ (R _ _ (R _ _ .pb26 .cl1058 .v26) .cl1061 .v25) .cl1064 .v24) (\ empty empty))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
;;
